{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf440
{\fonttbl\f0\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 // Termite College\cf0 \
\cf2 // (Tim Walters) (CC 2006)\cf0 \
\
\cf2 // Features recursively generated phase modulation trees\
//\cf0 \
\cf2 // Requires the GVerb and BEQsuite UGens, downloadable at\
// http://realizedsound.net/downloads\
\cf0 \
s.serverRunning.not.if(\{ s.boot \});\
\
(\
\cf3 var\cf0  pmSynthDefFactory;\
		\
pmSynthDefFactory = \{\
	\cf3 |name, out = 0, flatness = 6, maxOperators = 32, flavor = 0, attack = 4.0, release = 4.0, \
		sustain = 1.0, trace = false|\cf0 \
	\cf3 var\cf0  freqFuncs, freqModFunc, depthFunc, minNumModulatorsFunc;\
	\cf3 var\cf0  maxNumModulatorsFunc, levelSpec, pmtree;\
\
	\cf2 // This does timbral shifts by modulating volume of individual operators\cf0 \
	depthFunc = \{ \cf3 LinExp\cf0 .kr(\cf3 LFNoise1\cf0 .kr(exprand(0.1, 2.0)), -1, 1, 0.1, 1.0) \};\
	\
	\cf2 // Three flavors\cf0 \
	freqFuncs = [\
		\{ exprand(0.125, 4000) \},\
		\{ exprand(40, 4000) \},\
		\{ exprand(80, 500) \}\
	];\
	\
	\cf2 // Destabilize oscillators a bit.\cf0 \
	\cf2 // Would need a LinExp for proper tuning, but here\cf0 \
	\cf2 // we don't care.\cf0 \
	freqModFunc = \{ \cf3 BrownNoise\cf0 .kr.range(0.998, 0.998.reciprocal) \};\
	\
	\cf2 // This could be something more interesting\cf0 \
	minNumModulatorsFunc = \{\
		\cf3 |level|\cf0 \
		1\
	\};\
	\
	\cf2 // Tree thins out slowly with increasing depth\cf0 \
	maxNumModulatorsFunc = \{\
		\cf3 |level|\cf0 \
		(level.reciprocal.sqrt * flatness).asInteger + 1;\
	\};\
	\
	\cf2 // Generate tree of given size. If trace is true, dumps representation to post window.\cf0 \
	pmtree = \{\
		\cf3 |level, size, trace = false|\cf0 \
		\cf3 var\cf0  numModulators, numSubOperators, modGroup, thisUnitDepth, freq, freqMod;\
		\cf3 var\cf0  output, newSizes;\
		\
		\cf2 // Keep root oscillator in normal note range\cf0 \
		freq = (level == 1).if(\
			\{ exprand(80, 500) \},\
			\{ freqFuncs.wrapAt(flavor).value \}\
		);\
		trace.if(\{\
			(level - 1).do(\{ \cf4 "-"\cf0 .post \});\
			freq.postln;\
		\});\
		freqMod = freqModFunc.value;\
		numSubOperators = size - 1;\
		\
		\cf2 // Keep root oscillator at appropriate volume (don't modulate)\cf0 \
		thisUnitDepth = (level == 1).if(\
			\{ -18.dbamp * \cf3 AmpComp\cf0 .kr(freq) \}, \
			\{ depthFunc.value \}\
		);\
		\
		\cf2 // Choose number of tree branches, based on current level\cf0 \
		numModulators = (\
			minNumModulatorsFunc.value(level)..maxNumModulatorsFunc.value(level)\
		).choose.min(numSubOperators);\
		\
		\cf2 // Recursively generate subtrees, dividing up size among them.\cf0 \
		(size == 0).if(\{\
			output = 0\
		\}, \{\
			(numModulators == 0).if(\{\
				modGroup = 0\
			\}, \{\
				newSizes = 0 ! numModulators;\
				numSubOperators.do(\{\
					\cf3 var\cf0  index;\
					index = rrand(0, numModulators - 1);\
					newSizes[index] = newSizes[index] + 1;\
				\});\
				modGroup = \cf3 Mix\cf0 .ar(\{\
					\cf3 |i|\cf0 \
					pmtree.value(level + 1, newSizes[i], trace) \
				\} ! numModulators);\
			\});\
			\
			\cf2 // Return sine oscillator with subtrees summed as phase modulator\cf0 \
			output = \cf3 SinOsc\cf0 .ar(freq * freqMod, modGroup, thisUnitDepth);\
		\});\
		output\
	\};\
	\
	\cf2 // Generate synthdef from tree. Use audio rate panning for stereo, \cf0 \
	\cf2 // with modulated width.\cf0 \
	\cf3 SynthDef\cf0 .new(name ? \cf5 \\PMTree\cf0 , \{\
		\cf3 |attack = 4.0, release = 4.0, sustain = 1.0, gate = 1.0|\cf0 \
		\cf3 var\cf0  env;\
		env = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .asr(attack, sustain, release, curve: [4, -4]), gate, doneAction: 2);\
		\cf3 Out\cf0 .ar(out, \cf3 Pan2\cf0 .ar(\
			pmtree.value(1, maxOperators, trace), \
			\cf3 SinOsc\cf0 .ar(freqFuncs.wrapAt(flavor).value, 0, depthFunc.value, rrand(-0.5, 0.5)),\
			env\
		));\
	\})\
\};\
\
~synths = \cf3 Set\cf0 [];\
\
~effectBus = \cf3 Bus\cf0 .audio(s, 2);\
\
\cf2 // Add some reverb.\cf0 \
~effect = \{\
	\cf3 |gate = 1.0|\cf0 \
	\cf3 var\cf0  env;\
	env = \cf3 EnvGen\cf0 .ar(\cf3 Env\cf0 .asr(0, 1.0, 16.0), gate, doneAction: 2);\
	\cf3 GVerb\cf0 .ar(\
		\cf2 // Tame those pesky upper mids.\cf0 \
		\cf3 BPeakEQ\cf0 .ar(\cf3 In\cf0 .ar(~effectBus.index), 4000.0, 0.5, -6),\
		roomsize: 50, \
		earlyreflevel: -9.dbamp, \
		taillevel: -12.dbamp,\
		mul: env\
	)\
\}.play;\
\
\cf2 // Player generates and plays synths of random size and flavor.\cf0 \
~player = \cf3 Task\cf0 (\{\
	\cf3 var\cf0  synthName, polyphony;\
	polyphony = 4;\
	\cf3 inf\cf0 .do(\{\
		\cf3 |i|\cf0 \
		\cf3 var\cf0  targetNumSynths;\
		synthName = (\cf4 "PMTree"\cf0  ++ (i % 100).asString).asSymbol;\
		targetNumSynths = rrand(1, polyphony - 1);\
		\{~synths.size > targetNumSynths\}.while(\{\
			~synths.remove(~synths.choose.release);\
		\});\
		~synths.add(\
			pmSynthDefFactory.value(\
				synthName, \
				~effectBus.index, \
				exprand(2.0, 9.0).asInteger, \
				exprand(4.0, 33.0).asInteger,\
				[0, 0, 0, 0, 1, 2].choose,\
				exprand(1.0, 8.0), \
				exprand(4.0, 16.0), \
				4.0\
			).play\
		);\
		exprand(12.0, 36.0).wait;\
	\});\
\});\
\
~player.start;\
)\
\
(\
\cf2 // Execute to finish.\cf0 \
~player.stop;		\
~synths.do(\{ \cf3 |synth|\cf0  ~synths.remove(synth.release) \});\
~effect.release;\
)\
\
(\
\cf2 // Execute after sound has completely died away.\cf0 \
~effectBus.free;\
)}