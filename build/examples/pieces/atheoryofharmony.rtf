{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf440
{\fonttbl\f0\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 // a theory of harmony\cf0 \
\cf2 // (Nick Collins) (CC 2007)\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf2 //plaintive chords patch demonstrating scheduling attacks ahead of the beat and applying reverb\cf0 \
\cf2 //the chord transitions are adapted from an idea by John Eacott\cf0 \
\
\
\
\pard\pardeftab560\ql\qnatural
\cf2 //first send the SynthDefs; make sure the Server is on\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 (\
\cf3 SynthDef\cf0 (\cf4 \\slowatk\cf0 ,\{\cf3 arg\cf0  note=60,atk=0.2,pan=0.0,det=0.1,detrate=9,wrate=16, wspan=0.4;\
\cf3 var\cf0  slip,detune;\
\
detune=\cf3 SinOsc\cf0 .kr(detrate,0,det,det);\
\
slip= \cf3 Mix\cf0 .ar(\cf3 Pulse\cf0 .ar([note-detune,note+detune].midicps,\cf3 Lag\cf0 .kr(\cf3 LFNoise0\cf0 .kr(wrate,wspan,0.5)),0.1))*\cf3 EnvGen\cf0 .ar(\cf3 Env\cf0 ([0,1,0],[atk,0.5]),doneAction:2);\
\cf3 Out\cf0 .ar(0,\cf3 Pan2\cf0 .ar(slip,pan));\
\}).load(s);\
\
\cf3 SynthDef\cf0 (\cf4 \\fastatk\cf0 ,\{\cf3 arg\cf0  note=60,dcy=0.3,pan=0.0;\
\cf3 var\cf0  osc;\
\
osc= \cf3 LPF\cf0 .ar(\cf3 Mix\cf0 .ar(\cf3 LFPar\cf0 .ar(note.midicps,[0,1],0.12, \cf3 PinkNoise\cf0 .ar(\cf3 XLine\cf0 .kr(0.3,0.01,0.02)))), \cf3 Line\cf0 .kr(10000,200,0.1))\
*\cf3 EnvGen\cf0 .ar(\cf3 Env\cf0 ([0,1,0],[0.01,dcy]),doneAction:2);\
\
\cf3 Out\cf0 .ar(0,\cf3 Pan2\cf0 .ar(osc,pan));\
\}).send(s);\
\
\cf3 SynthDef\cf0 (\cf4 \\reverb\cf0 ,\{\
\cf3 var\cf0  a,c,z,y,in;\
c = 7; \cf2 // number of comb delays\cf0 \
a = 4; \cf2 // number of allpass delays\cf0 \
\
in=\cf3 In\cf0 .ar(0,2);\
\cf2 // reverb predelay time :\cf0 \
z = \cf3 DelayN\cf0 .ar(in, 0.048,0.048);\
\
\cf2 //for delaytime if want modulation-	//LFNoise1.kr(0.1.rand, 0.04, 0.05)\cf0 \
y=\cf3 Mix\cf0 .arFill(c,\{\cf3 CombL\cf0 .ar(z,0.1,rrand(0.01, 0.1),5)\});\
	\
\cf2 // chain of 4 allpass delays on each of two channels (8 total) :\cf0 \
a.do(\{ y = \cf3 AllpassN\cf0 .ar(y, 0.051, [rrand(0.01, 0.05),rrand(0.01, 0.05)], 1) \});\
	\
\cf2 // add original sound to reverb and play it :\cf0 \
\cf3 ReplaceOut\cf0 .ar(0,in+(0.2*y));\
\}).send(s)\
)\
\
\
\cf2 //now run the piece\cf0 \
(\
\cf3 var\cf0  sched;\
\cf3 var\cf0  chordtype,diatonic,transitions, current, strength, type;\
\cf3 var\cf0  revunit;\
\cf3 var\cf0  next,hits,hitset;\
\cf3 var\cf0  prevchord, ostinatostyle,which,base;\
\cf3 var\cf0  chordbias;\
\
prevchord=[60,64,67];\
ostinatostyle=4.rand;\
which=2.rand;\
\
revunit= \cf3 Synth\cf0 (\cf4 \\reverb\cf0 );\
\
chordbias= 1.0; \cf2 //0.7; //default 0.7\cf0 \
\
\cf2 //a quick list of chord types, ignoring any theory of extensions\cf0 \
chordtype= [\
[0,4,7],		\cf2 //maj\cf0 \
[0,4,7,11],	\cf2 //maj7\cf0 \
[0,3,7],		\cf2 //min\cf0 \
[0,3,7,10],	\cf2 //min7\cf0 \
[0,4,7,10],	\cf2 //dom 7\cf0 \
[0,3,6,10],	\cf2 //half dim\cf0 \
[0,3,6,9],	\cf2 //dim\cf0 \
[0,5,7]		\cf2 //sus4\cf0 \
];\
\
diatonic=[0,2,4,5,7,9,11];\
\
\cf2 //perversion of John Eacott's theory of pop harmony, from strong to weak\cf0 \
transitions=[-3,-2,3,1,2,-1,0];\
\
current=0;	\cf2 //start on tonic\cf0 \
strength=0;\
\
\cf3 SystemClock\cf0 .sched(0.0,\{	\
	\cf3 var\cf0  chord,root, adjust, whichroot, pans;\
	\cf3 var\cf0  chord3;\
	\
	if(0.2.coin,\{strength= (strength+rrand(1,2))%7\});\
	\
	current=(current+(transitions.at(strength)))%7;\
	\
	root=diatonic.at(current)+60;\
	\
	chord=chordtype.wchoose(\cf3 Array\cf0 .geom(8,1,0.7).normalizeSum)+root;\
	\
	adjust= (chord.size-1).rand;\
	\
	\cf2 //changing octave of some elements\cf0 \
	adjust.do(\{\cf3 arg\cf0  i; chord.put(chord.size-1-i,chord.at(chord.size-1-i)-12)\});\
	\
	\cf2 //make root the bass eight times out of ten\cf0 \
	whichroot= 0;\
	if(0.2.coin,\{whichroot=chord.size-1\});\
	\
	chord.put(whichroot,chord.at(whichroot)-24);\
	\
	chord.postln;\
	\
	pans= \cf3 Array\cf0 .fill(chord.size,\{\cf3 arg\cf0  i; (2.0*i)/(chord.size-1)-1.0;\});\
	\
	pans.scramble;\
	\
	\cf2 //can do 3.do which is v.pleasant\cf0 \
	chord.size.do(\{\cf3 arg\cf0  i;\
		\cf3 var\cf0  ahead;\
		\
		ahead= exprand(0.05,1.0);\
		\
		\cf3 SystemClock\cf0 .sched(1.0-ahead,\{\
		\cf3 Synth\cf0 .before(revunit,\cf4 \\slowatk\cf0 ,[\cf4 \\note\cf0 , chord.at(i), \cf4 \\atk\cf0 , ahead,\cf4 \\pan\cf0 , pans.at(i),\cf4 \\detrate\cf0 ,8.0.rand, \cf4 \\det\cf0 ,0.12.rand,\cf4 \\wrate\cf0 , [1,4,16].choose, \cf4 \\wspan\cf0 , 0.45.rand]);\
		\cf3 nil\cf0 \
		\});\
		\
	\});\
	\
	if(0.05.coin,\{ostinatostyle= 4.rand; which= 2.rand\});\
	\
	base= [chord,prevchord].at(which);\
	chord3= [base,base+12,base-12,(base%12).scramble+60].at(ostinatostyle);\
	\cf2 //jolly rhythm, can use prevchord or chord, can use plain chord instead of the modulo version\cf0 \
	\cf2 //chord3= chord+12; //(chord %12).scramble+60; chord-12; chord+12; chord\cf0 \
	\cf2 //chord3.postln;\cf0 \
	\
	next=[1.0,1.5,2.0,3.25].wchoose([0.32,0.32,0.32,0.04]);\
	\
	hits= (next/0.25).asInteger;\
	\
	\cf2 //hitset= Array.series(hits,0.0,0.5);\cf0 \
	hitset=\cf3 List\cf0 .new;\
	\
	hits.do(\{\cf3 arg\cf0  i; \
		\
		hitset.add(i*0.25);\
		if(0.1.coin,\{\
		hitset.add(i*0.25+0.125)\
		\});\
		\
	\});\
	\
	if(0.97.coin,\{	\
		hitset.do(\{\cf3 arg\cf0  val;\
		\
		\cf3 SystemClock\cf0 .sched(val,\{\
		\
		\cf2 //could be 3.do or chord3.do\cf0 \
		chord3.size.do(\{\cf3 arg\cf0  i;\
		\cf3 Synth\cf0 .after(revunit,\cf4 \\fastatk\cf0 ,[\cf4 \\note\cf0 ,chord3.at(i)]);\
		\});\
		\
		\cf3 nil\cf0 \});\
		\});\
	\});\
	\
	prevchord=chord;\
	\
	next\
\});\
\
\
)}