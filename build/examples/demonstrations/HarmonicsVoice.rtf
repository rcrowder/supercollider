{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf440
{\fonttbl\f0\fswiss\fcharset77 ArialMT;\f1\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red96\green96\blue96;}
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\fs43\fsmilli21800 \cf0 Adding harmonics to a voice input
\fs25\fsmilli12800 \
\
One easy way to add harmonics is to use the \ul [PitchShift]\ulnone  UGen. See its helpfile for more details.\
\
An alternative approach is to use the \ul [Pitch]\ulnone  UGen to track the pitch contour, and use that in synthesis. This allows you to generate sounds matching the pitch of the input but with any kind of texture.\
\
\pard\pardeftab720\ql\qnatural

\f1\fs18 \cf2 // (Dan Stowell) (public domain 2006)\
// USE HEADPHONES to prevent feedback.
\f0\fs25\fsmilli12800 \cf0 \

\f1\fs18 (\
x = \{\
\cf3 	var\cf0  son, freq, hasFreq, amp, out, harm;\
	son = \cf3 AudioIn\cf0 .ar(1); \cf2 // get first channel of sound input\cf0 \
	# freq, hasFreq = \cf3 Pitch\cf0 .kr(son); \cf2 // Pitch of input signal\cf0 \
	amp = \cf3 Amplitude\cf0 .ar(son); \cf2 // Amplitude of input signal\cf0 \
	\
	harm = \cf3 SinOsc\cf0 .ar(freq * 2, 0, amp * hasFreq);\
	\
	\cf3 Pan2\cf0 .ar(harm + son)\
\}.play;\
)\
\
x.free; \cf2 // Use this to stop the synth
\f0\fs25\fsmilli12800 \cf0 \
\
The above example adds only one harmonic. You can extend this to create multiple harmonics quite easily, for example by using an array of pitch ratios rather than a single ratio (and therefore creating an array of sine oscillators); or you could change the texture by using a more unusual oscillator (e.g. \ul [Saw]\ulnone  or \ul [Gendy1]\ulnone  or \ul [HenonN]\ulnone ).\
\
If you want a large number of controllable overtones then a bank of separate sine oscillators will become quite computationally intensive, so a good alternative is to use the general wavetable oscillator \ul [Osc]\ulnone  instead of SinOsc. The wavetable (a buffer) can be filled with a wave representing the harmonic profile you're interested in, and only one oscillator is needed to read it back.\
\
Let's implement this, and add a GUI for controlling the contents of the wavetable:\
\

\f1\fs18 \cf2 // (Dan Stowell, kernel) (gpl 2006)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf2 //first make and send the Synthdef so it's on the server\cf0 \
\
(\
\cf3 SynthDef\cf0 (\cf4 \\oscPlayer\cf0 , \{\cf3 |bufnum,balance=0.5,smooth=0.1|\cf0 \
\cf3 	var\cf0  input,freq,hasFreq,amp,mix,wet;	\
	input = \cf3 AudioIn\cf0 .ar(1); \cf2 // get first channel of sound input\cf0 \
	#freq,hasFreq = \cf3 Pitch\cf0 .kr(input); \cf2 // pitch of input signal\cf0 \
	amp = \cf3 Amplitude\cf0 .ar(input); \cf2 // amplitude of input signal\cf0 \
	wet = \cf3 Osc\cf0 .ar(bufnum,\cf3 Lag\cf0 .kr(freq,smooth), 0, amp);\
	mix = (input * (1-balance)) + (wet * balance); 	\
	\cf3 Out\cf0 .ar(0, \cf3 Pan2\cf0 .ar(mix));\
\}).send(s);\
)\
\
\cf2 // Now to instantiate the synth and build the GUI.\
\pard\pardeftab720\ql\qnatural
\cf2 // USE HEADPHONES to prevent feedback.\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf0 (\
\cf3 var\cf0  win,buf,m,harmonics,maxHarmonics=60,theSynth;\
\
win = \cf3 GUI.window.new\cf0 (\cf5 "input harmonica"\cf0 ,\cf3 Rect\cf0 (200,200,420,160)).front;\
\
harmonics = \cf3 Array\cf0 .fill(maxHarmonics,0);\
harmonics.put(0,1);			\cf2 // init array so first partial is alive\cf0 \
buf = \cf3 Buffer\cf0 .alloc(s, 4096, 1);	\cf2 // create buffer\cf0 \
buf.sine1(harmonics);			\cf2 // fill buffer\cf0 \
\
theSynth = \cf3 Synth\cf0 (\cf4 \\oscPlayer\cf0 , [\cf4 \\bufnum\cf0 , buf.bufnum], s);\
\
m = \cf3 GUI.multiSliderView.new\cf0 (win, \cf3 Rect\cf0 (5, 5, 350, 100))\
	.value_(harmonics)\
	.isFilled_(\cf3 true\cf0 )\
	.valueThumbSize_(3.0)\
	.indexThumbSize_(3.0)\
	.gap_(2)\
	.elasticMode_(1)\
	.action_(\{\cf3 |v|\cf0  buf.sine1(v.value)\}); \cf2 // fill buffer again\cf0 \
	\
\cf3 GUI.button.new\cf0 (win,\cf3 Rect\cf0 (5,110,70,20))\
	.states_([[\cf5 "CLEAR"\cf0 ,\cf3 Color\cf0 .green,\cf3 Color\cf0 .black]])\
	.action_(\{\cf3 var\cf0  temp;\
		temp = \cf3 Array\cf0 .fill(maxHarmonics,0);\
		buf.sine1(temp);\
		m.value_(temp);\
	\});\
	\
\cf3 GUI.button.new\cf0 (win,\cf3 Rect\cf0 (80,110,65,20))\
	.states_([[\cf5 "RAND"\cf0 ,\cf3 Color\cf0 .green,\cf3 Color\cf0 .black]])\
	.action_(\{\cf3 |v|\cf0  \cf3 var\cf0  temp;\
		temp = m.value.scramble;\
		buf.sine1(temp);\
		m.value_(temp);\
	\});\
	\
\cf3 SCButton\cf0 (win,\cf3 Rect\cf0 (150,110,20,20))\
	.states_([[\cf5 "<<"\cf0 ,\cf3 Color\cf0 .green,\cf3 Color\cf0 .black]])\
	.action_(\{\cf3 |v|\cf0  \cf3 var\cf0  temp;\
		temp = m.value.rotate(-1);\
		buf.sine1(temp);\
		m.value_(temp);\
	\});\
	\
\cf3 GUI.button.new\cf0 (win,\cf3 Rect\cf0 (175,110,20,20))\
	.states_([[\cf5 ">>"\cf0 ,\cf3 Color\cf0 .green,\cf3 Color\cf0 .black]])\
	.action_(\{\cf3 |v|\cf0  \cf3 var\cf0  temp;\
		temp = m.value.rotate(1);\
		buf.sine1(temp);\
		m.value_(temp);\
	\});\
	\
\cf3 GUI.slider.new\cf0 (win, \cf3 Rect\cf0 (365,5,20,100))\
	.value_(0.1)\
	.action_(\{\cf3 |v|\cf0  theSynth.set(\cf4 \\smooth\cf0 ,[0,1,\cf4 \\lin\cf0 ,0.001].asSpec.unmap(v.value))\});\
	\
\cf3 GUI.slider.new\cf0 (win, \cf3 Rect\cf0 (390,5,20,100))\
	.value_(0.5)\
	.action_(\{\cf3 |v|\cf0  theSynth.set(\cf4 \\balance\cf0 ,v.value)\});\
)\
}