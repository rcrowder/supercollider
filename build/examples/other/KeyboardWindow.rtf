{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf440
{\fonttbl\f0\fnil\fcharset77 Monaco;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Bold;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red191\green0\blue0;\red0\green0\blue191;
\red191\green0\blue0;\red96\green96\blue96;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 \
\cf3 // james mccartney \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs30 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b\fs28 \cf0 Triggering functions from the Keyboard\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs30 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 Drag Functions to keys in the window.\
Typing keys will execute the Function.\
If the Function returns another Function, the new Function will\
replace the action of a key.
\fs30 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs18 \cf0 \
(\
\cf4 var\cf0  w; \cf5 // window object\cf0 \
\cf4 var\cf0  courier; \cf5 // font object\cf0 \
\
\cf5 // an Array of Strings representing the key layout.\cf0 \
\cf4 var\cf0  keyboard = #[\cf6 "`1234567890-="\cf0 , \cf6 "QWERTYUIOP[]\\\\"\cf0 , \
							\cf6 "ASDFGHJKL;'"\cf0 , \cf6 "ZXCVBNM,./"\cf0 ];\
\
\cf5 // horizontal offsets for keys.\cf0 \
\cf4 var\cf0  offsets = #[42, 48, 57, 117];\
\
\cf4 var\cf0  actions; \cf5 // an IdentityDictionary mapping keys to action functions.\cf0 \
\cf4 var\cf0  makeKey; \cf5 // function to create an SCDragSink for a key.\cf0 \
\
courier = \cf4 Font\cf0 (\cf6 "Courier-Bold"\cf0 , 14);\
\
\cf5 // an IdentityDictionary is used to map keys to functions so that\cf0 \
\cf5 // we can look up the action for a key\cf0 \
actions = \cf4 IdentityDictionary\cf0 .new; \cf5 // create actions dictionary\cf0 \
\
\cf5 // define a function that will create an SCDragSink for a key.\cf0 \
makeKey = \{\cf4 |char, keyname, bounds|\cf0 \
	\cf4 var\cf0  v;\
\
	keyname = keyname ? char.asString;\
	bounds = bounds ? (24 @ 24);\
\
	v = \cf4 SCDragBoth\cf0 (w, bounds);\
	v.font = courier;\
	v.string = keyname;\
	v.align = \cf7 \\center\cf0 ;\
	v.setBoth = \cf4 false\cf0 ;\
	v.canReceiveDragHandler = \{\
		\cf4 SCView\cf0 .currentDrag.isKindOf(\cf4 Function\cf0 )\
	\};\
	v.action = \{ \
		(\cf6 "added key action : "\cf0  ++ keyname).postln;\
		if (char.isAlpha) \{\
			actions[char.toUpper] = v.object;\
			actions[char.toLower] = v.object;\
		\}\{\
			actions[char] = v.object;\
		\};\
		w.front;\
	\};\
\};\
\
w = \cf4 SCWindow\cf0 (\cf6 "keyboard"\cf0 , \cf4 Rect\cf0 (128, 320, 420, 150));\
\
w.view.decorator = \cf4 FlowLayout\cf0 (w.view.bounds);\
\
\cf5 // define a function to handle key downs.\cf0 \
w.view.keyDownAction = \{\cf4 |view, char, modifiers, unicode, keycode|\cf0 \
	 \cf4 var\cf0  result;\
	 \
	\cf5 // call the function\cf0 \
	result = actions[char].value(char, modifiers);\
	\
	\cf5 // if the result is a function, that function becomes the \cf0 \
	\cf5 // new action for the key\cf0 \
	if (result.isKindOf(\cf4 Function\cf0 )) \{\
		actions[char] = result;\
	\};\
\};\
\
\cf5 // make the rows of the keyboard\cf0 \
keyboard.do \{\cf4 |row, i|\cf0  \
	row.do \{\cf4 |key|\cf0  makeKey.(key) \};\
	if (i==0) \{ makeKey.(127.asAscii, \cf6 "del"\cf0 , 38 @ 24) \};\
	if (i==2) \{ makeKey.($\\r, \cf6 "retrn"\cf0 , 46 @ 24) \};\
	w.view.decorator.nextLine;\
	w.view.decorator.shift(offsets[i]);\
\};\
\
\cf5 // make the last row\cf0 \
makeKey.($ , \cf6 "space"\cf0 , 150 @ 24);\
makeKey.(3.asAscii, \cf6 "enter"\cf0 , 48 @ 24);\
\
w.front;\
)\
\
\
\
\
\cf5 ////////////////////\cf0 \
\
\cf5 // Drag these things to the keyboard to test it.\cf0 \
\
(\
\{\
	\cf4 var\cf0  synth, original;\
	original = \cf4 thisFunction\cf0 ;\
	synth = \{ \cf4 SinOsc\cf0 .ar(exprand(500,1200),0,0.2) \}.play;\
	\{ synth.free; original \}\
\}\
)\
\
\
(\
\{\
	\{ \
		\cf4 Pan2\cf0 .ar(\
			\cf4 SinOsc\cf0 .ar(\
				\cf4 ExpRand\cf0 (300,3000), \
				0,\
				\cf4 SinOsc\cf0 .kr(\cf4 ExpRand\cf0 (1,15),0,0.05).max(0)), \
			\cf4 Rand\cf0 (-1,1)) \
	\}.play;\
\}\
)\
\
\{ s.sendMsg(\cf7 \\n_free\cf0 , \cf7 \\h\cf0 , 0); \} \cf5 // kill head\cf0 \
\
\{ s.sendMsg(\cf7 \\n_free\cf0 , \cf7 \\t\cf0 , 0); \} \cf5 // kill tail\cf0 \
\
(\
\{\{\
	\cf4 var\cf0  eg, o, freq, noise;\
	eg = \cf4 EnvGen\cf0 .kr(\cf4 Env\cf0 .linen(0.1,2,0.4,0.2), doneAction: 2);\
	freq = \cf4 Rand\cf0 (600,1200);\
	noise = \{\cf4 LFNoise2\cf0 .ar(freq*0.1, eg)\}.dup;\
	o = \cf4 SinOsc\cf0 .ar(freq,0,noise);\
	\cf4 Out\cf0 .ar(0, o);\
\}.play\})\
\
\
(\
\{\{\
	\cf4 var\cf0  in, sr;\
    in = \cf4 LFSaw\cf0 .ar([21000,21001], 0, \cf4 LFPulse\cf0 .kr(\cf4 ExpRand\cf0 (0.1,1),0,0.3,0.2,0.02));\
    sr = \cf4 ExpRand\cf0 (300,3000) + [-0.6,0.6];\
	\cf4 Out\cf0 .ar(0,  \cf4 RLPF\cf0 .ar(in * \cf4 LFPulse\cf0 .ar(sr, 0, \cf4 MouseY\cf0 .kr(0.01, 0.99)), sr * (\cf4 LFPulse\cf0 .kr(\cf4 ExpRand\cf0 (0.1,12),0,0.4,0.2,0.2) + \cf4 LFPulse\cf0 .kr(\cf4 ExpRand\cf0 (0.1,12),0,0.7,0.2)), 0.1));\
\}.play;\})\
\
(\
\{\{ \cf4 var\cf0  in;\
	in = \cf4 In\cf0 .ar(0,2);\
	\cf4 ReplaceOut\cf0 .ar(0, \cf4 CombN\cf0 .ar(in, 0.24, 0.24, 8, 1, in.reverse).distort);\
\}.play\})\
\
(\
\{\{ \cf4 var\cf0  in;\
	in = \cf4 In\cf0 .ar(0,2);\
	\cf4 ReplaceOut\cf0 .ar(0, in * \cf4 SinOsc\cf0 .ar(\cf4 MouseX\cf0 .kr(2,2000,1)));\
\}.play\})\
\
}