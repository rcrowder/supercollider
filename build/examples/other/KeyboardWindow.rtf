{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf440
{\fonttbl\f0\fnil\fcharset77 Monaco;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Bold;
}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red0\green0\blue0;
\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;\red0\green115\blue0;\red0\green115\blue0;
}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf0 \
\cf2 // james mccartney \cf0 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\fs30 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2\b\fs28 \cf0 Triggering functions from the Keyboard\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0\fs30 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 Drag Functions to keys in the window.\
Typing keys will execute the Function.\
If the Function returns another Function, the new Function will\
replace the action of a key.
\fs30 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs18 \cf0 \
\cf3 GUI\cf0 .cocoa;	\cf2 // use CocoaGUI (Mac OS X native)\cf0 \
\cf3 GUI\cf0 .swing;	\cf2 // use SwingGUI (Java based GUI)\cf0 \
\
(\cf4 \
\cf5 var\cf4  w; \cf6 // window object\cf4 \
\cf5 var\cf4  courier; \cf6 // font object\cf4 \
\
\cf6 // an Array of Strings representing the key layout.\cf4 \
\cf5 var\cf4  keyboard = #[\cf7 "`1234567890-="\cf4 , \cf7 "QWERTYUIOP[]\\\\"\cf4 , \
							\cf7 "ASDFGHJKL;'"\cf4 , \cf7 "ZXCVBNM,./"\cf4 ];\
\
\cf6 // horizontal offsets for keys.\cf4 \
\cf5 var\cf4  offsets = #[42, 48, 57, 117];\
\
\cf5 var\cf4  actions; \cf6 // an IdentityDictionary mapping keys to action functions.\cf4 \
\cf5 var\cf4  makeKey; \cf6 // function to create an SCDragSink for a key.\cf4 \
\
courier = \cf5 GUI\cf4 .font.new(\cf7 "Courier"\cf4 , 14).boldVariant;\
\
\cf6 // an IdentityDictionary is used to map keys to functions so that\cf4 \
\cf6 // we can look up the action for a key\cf4 \
actions = \cf5 IdentityDictionary\cf4 .new; \cf6 // create actions dictionary\cf4 \
\
\cf6 // define a function that will create an SCDragSink for a key.\cf4 \
makeKey = \{\cf5 |char, keyname, bounds|\cf4 \
	\cf5 var\cf4  v, clz;\
\
	keyname = keyname ? char.asString;\
	bounds = bounds ? (24 @ 24);\
\
	v = \cf5 GUI\cf4 .dragBoth.new(w, bounds);\
	v.font = courier;\
	v.string = keyname;\
	v.align = \cf8 \\center\cf4 ;\
	v.setBoth = \cf5 false\cf4 ;\
	clz = \cf5 GUI\cf4 .view;\
	v.canReceiveDragHandler = \{\
		clz.currentDrag.isKindOf(\cf5 Function\cf4 )\
	\};\
	v.action = \{ \
		(\cf7 "added key action : "\cf4  ++ keyname).postln;\
		if (char.isAlpha) \{\
			actions[char.toUpper] = v.object;\
			actions[char.toLower] = v.object;\
		\}\{\
			actions[char] = v.object;\
		\};\
		w.front;\
	\};\
\};\
\
w = \cf5 GUI\cf4 .window.new(\cf7 "keyboard"\cf4 , \cf5 Rect\cf4 (128, 320, 420, 150));\
\
w.view.decorator = \cf5 FlowLayout\cf4 (w.view.bounds);\
\
\cf6 // define a function to handle key downs.\cf4 \
w.view.keyDownAction = \{\cf5 |view, char, modifiers, unicode, keycode|\cf4 \
	 \cf5 var\cf4  result;\
	 \
	\cf6 // call the function\cf4 \
	result = actions[char].value(char, modifiers);\
	\
	\cf6 // if the result is a function, that function becomes the \cf4 \
	\cf6 // new action for the key\cf4 \
	if (result.isKindOf(\cf5 Function\cf4 )) \{\
		actions[char] = result;\
	\};\
\};\
\
\cf6 // make the rows of the keyboard\cf4 \
keyboard.do \{\cf5 |row, i|\cf4  \
	row.do \{\cf5 |key|\cf4  makeKey.(key) \};\
	if (i==0) \{ makeKey.(127.asAscii, \cf7 "del"\cf4 , 38 @ 24) \};\
	if (i==2) \{ makeKey.($\\r, \cf7 "rtrn"\cf4 , 46 @ 24) \};\
	w.view.decorator.nextLine;\
	w.view.decorator.shift(offsets[i]);\
\};\
\
\cf6 // make the last row\cf4 \
makeKey.($ , \cf7 "space"\cf4 , 150 @ 24);\
makeKey.(3.asAscii, \cf7 "entr"\cf4 , 48 @ 24);\
\
w.front;\
\cf0 )\
\
\
\
\
\cf2 ////////////////////\cf0 \
\
\cf2 // Drag these things to the keyboard to test it.\cf0 \
\
(\
\{\
	\cf3 var\cf0  synth, original;\
	original = \cf3 thisFunction\cf0 ;\
	synth = \{ \cf3 SinOsc\cf0 .ar(exprand(500,1200),0,0.2) \}.play;\
	\{ synth.free; original \}\
\}\
)\
\
\
(\
\{\
	\{ \
		\cf3 Pan2\cf0 .ar(\
			\cf3 SinOsc\cf0 .ar(\
				\cf3 ExpRand\cf0 (300,3000), \
				0,\
				\cf3 SinOsc\cf0 .kr(\cf3 ExpRand\cf0 (1,15),0,0.05).max(0)), \
			\cf3 Rand\cf0 (-1,1)) \
	\}.play;\
\}\
)\
\
\{ s.sendMsg(\cf9 \\n_free\cf0 , \cf9 \\h\cf0 , 0); \} \cf2 // kill head\cf0 \
\
\{ s.sendMsg(\cf9 \\n_free\cf0 , \cf9 \\t\cf0 , 0); \} \cf2 // kill tail\cf0 \
\
(\
\{\{\
	\cf3 var\cf0  eg, o, freq, noise;\
	eg = \cf3 EnvGen\cf0 .kr(\cf3 Env\cf0 .linen(0.1,2,0.4,0.2), doneAction: 2);\
	freq = \cf3 Rand\cf0 (600,1200);\
	noise = \{\cf3 LFNoise2\cf0 .ar(freq*0.1, eg)\}.dup;\
	o = \cf3 SinOsc\cf0 .ar(freq,0,noise);\
	\cf3 Out\cf0 .ar(0, o);\
\}.play\})\
\
\
(\
\{\{\
	\cf3 var\cf0  in, sr;\
    in = \cf3 LFSaw\cf0 .ar([21000,21001], 0, \cf3 LFPulse\cf0 .kr(\cf3 ExpRand\cf0 (0.1,1),0,0.3,0.2,0.02));\
    sr = \cf3 ExpRand\cf0 (300,3000) + [-0.6,0.6];\
	\cf3 Out\cf0 .ar(0,  \cf3 RLPF\cf0 .ar(in * \cf3 LFPulse\cf0 .ar(sr, 0, \cf3 MouseY\cf0 .kr(0.01, 0.99)), sr * (\cf3 LFPulse\cf0 .kr(\cf3 ExpRand\cf0 (0.1,12),0,0.4,0.2,0.2) + \cf3 LFPulse\cf0 .kr(\cf3 ExpRand\cf0 (0.1,12),0,0.7,0.2)), 0.1));\
\}.play;\})\
\
(\
\{\{ \cf3 var\cf0  in;\
	in = \cf3 In\cf0 .ar(0,2);\
	\cf3 ReplaceOut\cf0 .ar(0, \cf3 CombN\cf0 .ar(in, 0.24, 0.24, 8, 1, in.reverse).distort);\
\}.play\})\
\
(\
\{\{ \cf3 var\cf0  in;\
	in = \cf3 In\cf0 .ar(0,2);\
	\cf3 ReplaceOut\cf0 .ar(0, in * \cf3 SinOsc\cf0 .ar(\cf3 MouseX\cf0 .kr(2,2000,1)));\
\}.play\})\
\
}