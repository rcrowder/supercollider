<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.47">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica; min-height: 18.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Futura; min-height: 15.0px}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Futura}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #982316; min-height: 12.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0025b2}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #982316}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #606060; min-height: 12.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Helvetica}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 16.0px Helvetica}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Helvetica; min-height: 16.0px}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #416d1f}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
span.s1 {text-decoration: underline}
span.s2 {color: #0025b2}
span.s3 {color: #000000}
span.s4 {color: #416d1f}
span.s5 {color: #982316}
span.s6 {font: 9.0px Monaco}
span.s7 {font: 12.0px Helvetica; color: #0024f8}
span.s8 {color: #606060}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>proxy space examples</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><br></p>
<p class="p4"><br></p>
<p class="p5"><span class="s1">preparation of the environment</span></p>
<p class="p6"><br></p>
<p class="p7">(</p>
<p class="p7">s = <span class="s2">Server</span>.local;</p>
<p class="p7">s.boot;</p>
<p class="p8">p = ProxySpace<span class="s3">.push(s);</span></p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">playing and monitoring</span></p>
<p class="p3"><br></p>
<p class="p9">// play some output to the hardware busses, this could be any audio rate key.</p>
<p class="p7">~out.play;</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar([400, 408]*0.8, 0, 0.2) };</p>
<p class="p10"><br></p>
<p class="p3"><br></p>
<p class="p9">// replacing the node. the crossfade envelope is created internally.</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar([443, 600-Rand(0,200)], 0, 0.2) };</p>
<p class="p7">~out = { <span class="s2">Resonz</span>.ar(<span class="s2">Saw</span>.ar(40+[0,0.2], 1), [1200, 1600], 0.1) + <span class="s2">SinOsc</span>.ar(60*[1,1.1],0,0.2) };</p>
<p class="p7">~out = { <span class="s2">Pan2</span>.ar(<span class="s2">PinkNoise</span>.ar(0.1), <span class="s2">LFClipNoise</span>.kr(2)) };</p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">setting the node controls</span></p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">arg</span> rate=2; <span class="s2">Pan2.ar</span>(<span class="s2">PinkNoise</span>.ar(0.1), <span class="s2">LFClipNoise</span>.kr(rate)) };</p>
<p class="p7">~out.set(<span class="s4">\rate</span>, 30);</p>
<p class="p7">~out = { <span class="s2">arg</span> rate=2; <span class="s2">Pan2</span>.ar(<span class="s2">Dust</span>.ar(2000, 0.2), <span class="s2">LFClipNoise</span>.kr(rate)) };</p>
<p class="p7">~out.set(<span class="s4">\rate</span>, 2);</p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">referencing between proxies</span></p>
<p class="p3"><br></p>
<p class="p7">~lfo = { <span class="s2">LFNoise2</span>.kr(30, 300, 500) };</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(~lfo.kr, 0, 0.15)<span class="Apple-converted-space">  </span>};</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(~lfo.kr * [1, 1.2], 0, 0.1) * <span class="s2">Pulse</span>.ar(~lfo.kr * [0.1, 0.125], 0.5) };</p>
<p class="p7">~lfo = { <span class="s2">LFNoise1</span>.kr(30, 40) + <span class="s2">SinOsc</span>.kr(0.1, 0, 200, 500) };</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(~lfo.kr * [1, 1.2], 0, 0.1)<span class="Apple-converted-space">  </span>};</p>
<p class="p7">~lfo = 410;</p>
<p class="p4"><br></p>
<p class="p5"><span class="s1">math</span></p>
<p class="p3"><br></p>
<p class="p9">// unary operators</p>
<p class="p7">~lfo2 = { <span class="s2">SinOsc</span>.kr(0.5, 0, 600, 100)<span class="Apple-converted-space">  </span>};</p>
<p class="p7">~lfo = ~lfo2.abs;</p>
<p class="p7">~lfo2 = { <span class="s2">SinOsc</span>.kr(1.3, 0, 600, 100)<span class="Apple-converted-space">  </span>};</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// binary operators</p>
<p class="p7">~lfo3 = { <span class="s2">LFTri</span>.kr(0.5, 0, 80, 300) };</p>
<p class="p7">~lfo = ~lfo2 + ~lfo3;</p>
<p class="p7">~lfo = ~lfo3;</p>
<p class="p7">~lfo = (~lfo3 / 50).sin * 200 + 500 * { <span class="s2">LFTri</span>.kr(~lfo.kr * 0.0015, 0, 0.1 * ~lfo3.kr / 90, 1) };</p>
<p class="p7">~lfo3 = { <span class="s2">Mix</span>(~lfo2.kr * [1, 1.2]) };</p>
<p class="p3"><br></p>
<p class="p7">currentEnvironment.free; <span class="s5">// free all node proxies</span></p>
<p class="p9"><span class="s3">~out.stop; </span>// free the playback synth.</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">waking up a network of proxies</span></p>
<p class="p3"><br></p>
<p class="p9">// hit cmd-. to stop all nodes</p>
<p class="p9">// start again</p>
<p class="p7">~out.play;<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">feeding back</span> (one buffer size delay)</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar([220, 330], ~out.ar(2).reverse * <span class="s2">LFNoise2</span>.kr(0.5, 4*pi), 0.4) };</p>
<p class="p3"><br></p>
<p class="p9">// there is no immediacy: hear the buffer size cycle</p>
<p class="p7">~out = { <span class="s2">Impulse</span>.ar(1 ! 2) + (~out.ar(2) * 0.99) };<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// supercollider 'differential equations'</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(<span class="s2">Slope</span>.ar(~out.ar) * <span class="s2">MouseX</span>.kr(1000, 18000, 1)) * 0.1 + <span class="s2">SinOsc</span>.ar(100, 0, 0.1) };</p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7">~out = { <span class="s2">var</span> z, zz;</p>
<p class="p7"><span class="Apple-tab-span">	</span>z = <span class="s2">Slope</span>.ar(~out.ar);</p>
<p class="p7"><span class="Apple-tab-span">	</span>zz = <span class="s2">Slope</span>.ar(z);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">SinOsc</span>.ar(Rand(300,410), z) *</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">SinOsc</span>.ar(zz * 410)<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span>* 0.1 + <span class="s2">Decay2</span>.ar(<span class="s2">Pan2</span>.ar(<span class="s2">Dust</span>.ar(600), <span class="s2">MouseX</span>.kr(-1,1)), 0.01, 0.05);</p>
<p class="p7">}</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">multiple control</span></p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7">~out = { <span class="s2">arg</span> freqOffest;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">var</span> ctl;</p>
<p class="p7"><span class="Apple-tab-span">	</span>ctl = <span class="s2">Control</span>.names(<span class="s4">\array</span>).kr(<span class="s2">Array</span>.rand(8, 400, 1000));</p>
<p class="p7"><span class="Apple-tab-span">	</span>Pan2.ar(<span class="s2">Mix</span>(<span class="s2">SinOsc</span>.ar(ctl + freqOffest, 0, 0.1 / 8)), LFNoise0.kr(2))</p>
<p class="p7">};</p>
<p class="p7">)<span class="Apple-tab-span">	</span></p>
<p class="p3"><br></p>
<p class="p7">~out.setn(<span class="s4">\array</span>, <span class="s2">Array</span>.exprand(8, 400, 2000));</p>
<p class="p7">~out.set(<span class="s4">\freqOffest</span>, rrand(300,200));</p>
<p class="p7">~out.map(<span class="s4">\freqOffest</span>, ~lfo);</p>
<p class="p3"><br></p>
<p class="p9">// a simpler short form for this is:</p>
<p class="p7">(</p>
<p class="p7">~out = { <span class="s2">arg</span> freqOffest=0, array = #[ 997, 777, 506, 553, 731, 891, 925, 580 ];</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Pan2</span>.ar(<span class="s2">Mix</span>(<span class="s2">SinOsc</span>.ar(array + freqOffest, 0, 0.1 / 8)), <span class="s2">LFNoise0</span>.kr(2))</p>
<p class="p7">};</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">mixing</span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">~out1 = { <span class="s2">SinOsc</span>.ar(600, 0, 0.1) };</p>
<p class="p7">~out2 = { <span class="s2">SinOsc</span>.ar(500, 0, 0.1) };</p>
<p class="p7">~out3 = { <span class="s2">SinOsc</span>.ar(400, 0, 0.1) };</p>
<p class="p7">~out = ~out2 + ~out1 + ~out3;</p>
<p class="p3"><br></p>
<p class="p7">~out = ~out1 + ~out2;</p>
<p class="p7">~out = ~out1;</p>
<p class="p3"><br></p>
<p class="p9">// another way is:</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(600, 0, 0.1) };</p>
<p class="p7">~out.add({ <span class="s2">SinOsc</span>.ar(500, 0, 0.1) });</p>
<p class="p7">~out.add({ <span class="s2">SinOsc</span>.ar(400, 0, 0.1) });</p>
<p class="p3"><br></p>
<p class="p9">// or with direct access:</p>
<p class="p7">~out[1] = { <span class="s2">SinOsc</span>.ar(500 * 1.2, 0, 0.1) };</p>
<p class="p7">~out[2] = { <span class="s2">SinOsc</span>.ar(400 * 1.2, 0, 0.1) };</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">restoring / erasing</span></p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">~out.free; </span>// this frees the group, not the play synth x</p>
<p class="p9"><span class="s3">~out.send; </span>// resends all synths</p>
<p class="p7">~out.free;<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s3">~out.send(</span><span class="s2">nil</span><span class="s3">, 1); </span>// this sends at index 1 only<span class="Apple-converted-space"> </span></p>
<p class="p7">~out.send;</p>
<p class="p6"><br></p>
<p class="p9">// removing:</p>
<p class="p7">~out.removeLast;</p>
<p class="p7">~out.removeAt(0);</p>
<p class="p3"><br></p>
<p class="p9">// cleaning up, freeing the bus:</p>
<p class="p9"><span class="s3">~out.clear; </span>// this neutralizes the proxy, and frees its bus</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5">for more on the proxy slots see:<span class="s6"> <a href="jitlib_basic_concepts_03.html"><span class="s7">jitlib_basic_concepts_03</span></a><span class="Apple-converted-space"> </span></span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">garbage collecting</span></p>
<p class="p3"><br></p>
<p class="p9">// often there are proxies playing that are not used anymore - this is good,</p>
<p class="p9">// because they might be used again at any time.<span class="Apple-converted-space"> </span></p>
<p class="p9">// this shows how to free unused proxies, such as ~out1, ~out2. <span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p7">~out.play;</p>
<p class="p7">~out = { <span class="s2">Pan2</span>.ar(<span class="s2">SinOsc</span>.ar(~lfo.kr, 0, 0.2), sin(~lfo.kr / 10)) }; <span class="s5">// ~lfo is kept, as its parents.</span></p>
<p class="p7">~lfo = { LFNoise2.kr(3, 160, 400) };</p>
<p class="p3"><br></p>
<p class="p7">p.keysValuesDo { <span class="s2">arg</span> key, proxy; [key, proxy.isPlaying].postln };</p>
<p class="p9"><span class="s3">p.reduce; </span>// all monitoring proxies (in this case ~out) are kept. equivalent: p.reduce(to: [~out]);</p>
<p class="p7">p.keysValuesDo { <span class="s2">arg</span> key, proxy; [key, proxy.isPlaying].postln };</p>
<p class="p3"><br></p>
<p class="p9">// to remove everything else:</p>
<p class="p7">p.postln;</p>
<p class="p9"><span class="s3">p.clean; </span>// all monitoring proxies (in this case ~out) are kept.</p>
<p class="p7">p.postln;</p>
<p class="p3"><br></p>
<p class="p9">// after ~out is stopped, it is removed, too:</p>
<p class="p9"><span class="s3">~out.stop; </span>// stop monitor</p>
<p class="p7">p.clean;<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s3">p.postln; </span>// empty space.</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">execution order</span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// you can .play .kr or .ar also a name that is not yet used.</p>
<p class="p9">// the rate is guessed as far as possible. on this topic see also: [the_lazy_proxy]</p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">~myOut.play; </span>// play some key (audio rate is assumed)</p>
<p class="p3"><br></p>
<p class="p9">// the rate is determined from the first access:<span class="Apple-converted-space"> </span></p>
<p class="p9">// like this ~lfo becomes control rate</p>
<p class="p3"><br></p>
<p class="p7">~myOut = { <span class="s2">SinOsc</span>.ar(~freq.kr * 2, 0, 0.1) };<span class="Apple-converted-space"> </span></p>
<p class="p7">~freq = 900;</p>
<p class="p7">~freq = { <span class="s2">SinOsc</span>.kr(115, 0, 70, 220) }</p>
<p class="p3"><br></p>
<p class="p7">~myOut = { <span class="s2">SinOsc</span>.ar(~otherFreq.ar * 2, 0, 0.1) };</p>
<p class="p7">~otherFreq = { <span class="s2">SinOsc</span>.ar(115, 0, 70, 220) };</p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">currentEnvironment.clear; </span>// clear every<span class="Apple-converted-space">  </span>proxy in this environment and remove them. (same: p.clear)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">setting the xfade time</span></p>
<p class="p3"><br></p>
<p class="p7">~out.play;</p>
<p class="p3"><br></p>
<p class="p7">~out.fadeTime = 4;</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) };</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) };</p>
<p class="p7">~out.fadeTime = 0.01;</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) };</p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(Rand(800, 300.0)*[1,1.1], 0, 0.1) };</p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">~out.free(3);<span class="Apple-converted-space">  </span></span>// release the synths and the group with a given fadeTime without changing proxy time</p>
<p class="p9"><span class="s3">~out.stop;<span class="Apple-tab-span">	</span></span>// stop monitor</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">setting and mapping arguments</span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">~out.play;</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">arg</span> freq=500, ffreq=120; <span class="s2">SinOsc</span>.ar(freq*[1,1.1], <span class="s2">SinOsc</span>.ar(ffreq, 0, pi), 0.2) };</p>
<p class="p7">~out.set(<span class="s4">\freq</span>, 400+100.rand2);</p>
<p class="p7">~out.set(<span class="s4">\freq</span>, 400+100.rand2);</p>
<p class="p7">~out.set(<span class="s4">\ffreq</span>, 30+20.rand2);</p>
<p class="p9"><span class="s3">~out.unset(</span><span class="s4">\freq</span><span class="s3">, </span><span class="s4">\ffreq</span><span class="s3">);<span class="Apple-converted-space">  </span></span>// remove the setting</p>
<p class="p7">~out.set(<span class="s4">\ffreq</span>, 30+10.rand2, <span class="s4">\freq</span>, 500 + 200.rand2);</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// argument settings and mappings are applied to every new function</p>
<p class="p7">~out = { <span class="s2">arg</span> freq=100, ffreq=20; <span class="s2">SinOsc</span>.ar(freq, SinOsc.ar(<span class="s2">SinOsc</span>.ar(ffreq)*ffreq, 0, pi), 0.2) };</p>
<p class="p3"><br></p>
<p class="p9">// mapping to other proxies</p>
<p class="p7">~lfo = { <span class="s2">SinOsc</span>.kr(0.3, 0, 80, 100) };</p>
<p class="p7">~out.map(<span class="s4">\ffreq</span>, ~lfo);</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">arg</span> freq=300, ffreq=20; <span class="s2">Pulse</span>.ar(freq*[1,1.1]+ <span class="s2">SinOsc</span>.ar(ffreq, 0, freq), 0.3, 0.1) };</p>
<p class="p7">~out = { <span class="s2">arg</span> freq=300, ffreq=20; <span class="s2">BPF</span>.ar(<span class="s2">LFSaw</span>.ar(ffreq*[1,1.1], 0, 1), freq, 0.2) };</p>
<p class="p3"><br></p>
<p class="p7">~lfo = { <span class="s2">FSinOsc</span>.kr(0.3, 0, 30, 200) + <span class="s2">FSinOsc</span>.kr(10, 0, 10) };</p>
<p class="p7">~out = { <span class="s2">arg</span> freq=300, ffreq=20; <span class="s2">SinOsc</span>.ar(freq*[1,1.1], <span class="s2">SinOsc</span>.ar(ffreq, 0, pi), 0.1) };</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// crossfaded setting and mapping: fadeTime is used</p>
<p class="p7">~out.fadeTime = 2;</p>
<p class="p7">~out.xset(<span class="s4">\freq</span>, 9000);</p>
<p class="p7">~out.xset(<span class="s4">\freq</span>, rrand(400, 700));</p>
<p class="p3"><br></p>
<p class="p7">~lfo = { <span class="s2">FSinOsc</span>.kr(0.1, 0, 30, 100) };</p>
<p class="p7">~lfo2 = { <span class="s2">LFClipNoise</span>.kr(3, 100, 200) };</p>
<p class="p7">~lfo3 = <span class="s2">StreamKrDur</span>(<span class="s2">Pseq</span>([<span class="s2">Prand</span>([530, 600],1), 700, 400, 800, 500].scramble, <span class="s2">inf</span>) / 3, 0.2);</p>
<p class="p3"><br></p>
<p class="p7">~out.xmap(<span class="s4">\ffreq</span>, ~lfo2);</p>
<p class="p7">~out.xmap(<span class="s4">\ffreq</span>, ~lfo);</p>
<p class="p7">~out.xmap(<span class="s4">\ffreq</span>, ~lfo3);</p>
<p class="p3"><br></p>
<p class="p9">// argument rates: just like a synthdef has input 'rates' (like \ir or \tr), a nodeproxy control</p>
<p class="p9">// can be given a rate. this rate is used for each function passed into the proxy.</p>
<p class="p6"><br></p>
<p class="p9">// trigger inputs</p>
<p class="p7">~out = { <span class="s2">arg</span> trig, dt=1; <span class="s2">Decay2</span>.kr(trig, 0.01, dt) * <span class="s2">Mix</span>(<span class="s2">SinOsc</span>.ar(7000*[1.2, 1.3, 0.2])) }</p>
<p class="p7">~out.setRates(\trig, \tr);</p>
<p class="p3"><br></p>
<p class="p9">// set the group, so the node proxy does not store the new value</p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, \dt, 0.1);<span class="Apple-converted-space"> </span></p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.4, \dt, 0.31);</p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.13, \dt, 2);</p>
<p class="p3"><br></p>
<p class="p9">// lagging controls:</p>
<p class="p9"><span class="s3">~out.lag(</span><span class="s4">\xfreq</span><span class="s3">, 1); </span>// equivalent to ~out.setRates(\xfreq, 1);</p>
<p class="p7">(</p>
<p class="p7">~out = { <span class="s2">arg</span> trig, dt=1, xfreq=700;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Decay2</span>.kr(trig, 0.01, dt) * <span class="s2">Mix</span>(<span class="s2">SinOsc</span>.ar(xfreq*[1.2, 1.3, 0.2]))<span class="Apple-converted-space"> </span></p>
<p class="p7">};</p>
<p class="p7">)</p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, <span class="s4">\dt</span>, 1, <span class="s4">\xfreq</span>, rrand(2000,9000));<span class="Apple-converted-space"> </span></p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, <span class="s4">\dt</span>, 0.5, <span class="s4">\xfreq</span>, rrand(2000,9000));<span class="Apple-converted-space"> </span></p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, <span class="s4">\dt</span>, 1, <span class="s4">\xfreq</span>, rrand(2000,9000));<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p9">// changing the lag, the synth is reconstructed with the new lag:</p>
<p class="p3"><br></p>
<p class="p7">~out.lag(<span class="s4">\xfreq</span>, 0.01);</p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, <span class="s4">\dt</span>, 1, <span class="s4">\xfreq</span>, rrand(2000,9000));<span class="Apple-converted-space"> </span></p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, <span class="s4">\dt</span>, 1, <span class="s4">\xfreq</span>, rrand(2000,9000));<span class="Apple-converted-space"> </span></p>
<p class="p7">~out.group.set(<span class="s4">\trig</span>, 0.1, <span class="s4">\dt</span>, 1, <span class="s4">\xfreq</span>, rrand(2000,9000));<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p9">// removing the trig rate:</p>
<p class="p7">~out.setRates(<span class="s4">\trig</span>, <span class="s2">nil</span>);</p>
<p class="p3"><br></p>
<p class="p9">// note that the same works with the i_ and the t_ arguments, just as it does in SynthDef</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p11">___________________________________________________________________</p>
<p class="p12">other possible inputs</p>
<p class="p13"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">using a synthdef as input</span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// for a more systematic overview see: [jitlib_fading]</p>
<p class="p6"><br></p>
<p class="p9">// you have the responsibility for the right number of channels and output rate</p>
<p class="p9">// you have to supply an 'out' argument so it can be mapped to the right channel.</p>
<p class="p6"><br></p>
<p class="p7">~out.play;</p>
<p class="p7">~out = <span class="s2">SynthDef</span>(<span class="s8">"w"</span>, { <span class="s2">arg</span> out=0; <span class="s2">Out</span>.ar(out,<span class="s2">SinOsc</span>.ar([<span class="s2">Rand</span>(430, 600), 600], 0, 0.2)) });</p>
<p class="p7">~out = <span class="s2">SynthDef</span>(<span class="s8">"w"</span>, { <span class="s2">arg</span> out=0; <span class="s2">Out</span>.ar(out,<span class="s2">SinOsc</span>.ar([<span class="s2">Rand</span>(430, 600), 500], 0, 0.2)) });</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// if you supply a gate it fades in and out. evaluate this several times</p>
<p class="p7">(</p>
<p class="p7">~out = <span class="s2">SynthDef</span>(<span class="s8">"w"</span>, { <span class="s2">arg</span> out=0, gate=1.0;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(out,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">SinOsc</span>.ar([<span class="s2">Rand</span>(430, 800), <span class="s2">Rand</span>(430, 800)], 0, 0.2) * <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.asr(1,1,1), gate, doneAction:2)</p>
<p class="p7"><span class="Apple-tab-span">	</span>)<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span>});</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p9">// once the SynthDef is sent, it can be assigned by name.<span class="Apple-converted-space"> </span></p>
<p class="p9">// using this method, a <span class="s1">gate argument</span> should be<span class="Apple-converted-space"> </span></p>
<p class="p9">// provided that releases the synth. (doneAction:2)</p>
<p class="p9">// this is very efficient, as the def is on the server already.</p>
<p class="p6"><br></p>
<p class="p9">// if the synth def is in the synthdesc lib (.store) its gate is detected.</p>
<p class="p6"><br></p>
<p class="p7">(</p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s8">"staub"</span>, { <span class="s2">arg</span> out, gate=1;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(out, <span class="s2">Ringz</span>.ar(<span class="s2">Dust</span>.ar(15), Rand(1, 3) * 3000*[1,1], 0.001) * <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.asr, gate, doneAction:2))<span class="Apple-converted-space"> </span></p>
<p class="p7">}).send(s);</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p7">~out = \staub;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// if you supply an envelope that frees itself, no bundle is sent to free it</p>
<p class="p7">(</p>
<p class="p7">~out = <span class="s2">SynthDef</span>(<span class="s8">"w"</span>, { arg out, lfo, f0=430;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(out,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">SinOsc</span>.ar([<span class="s2">Rand</span>(f0, 800), <span class="s2">Rand</span>(f0, 800)]+lfo, 0, 0.2) * <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.perc(0.01, 0.03), doneAction:2)</p>
<p class="p7"><span class="Apple-tab-span">	</span>)<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span>});</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p7">~out.spawn;</p>
<p class="p7">~out.spawn([\f0, 5000]);</p>
<p class="p7">fork { 5.do { ~out.spawn([\f0, 5000 + 1000.0.rand]); 0.1.wait; } }</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// when the synth description in the SynthDescLib is found for the symbol,</p>
<p class="p9">// the proxy can determine whether to release or to free the synth.</p>
<p class="p9">// so if there is no 'gate' arg provided and the def has a desc, the synth is</p>
<p class="p9">// freed and not released.<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s8">"staub"</span>, { <span class="s2">arg</span> out;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(out, <span class="s2">Ringz</span>.ar(<span class="s2">WhiteNoise</span>.ar(0.01), 1000*[1,1], 0.001))<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s3">}).store; </span>// store the synth def so it is added to the SynthDescLib</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">~out = \staub;</p>
<p class="p9"><span class="s3">~out = </span><span class="s4">\staub</span><span class="s3">; </span>// watching the synth count shows that the old synth is freed.</p>
<p class="p9"><span class="s3">~out = 0;<span class="Apple-converted-space">  <span class="Apple-tab-span">	</span></span></span>// now out plays continuous stream of zero.</p>
<p class="p9"><span class="s3">~out = </span><span class="s2">nil</span><span class="s3">;<span class="Apple-tab-span">	</span></span>// removes object and stops it.</p>
<p class="p4"><br></p>
<p class="p5"><span class="s1">using patterns</span></p>
<p class="p3"><br></p>
<p class="p9">// example</p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s8">"who"</span>, { <span class="s2">arg</span> amp=0.1, freq=440, detune=0, gate=1, out=0, ffreq=800;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">var</span> env;</p>
<p class="p7"><span class="Apple-tab-span">	</span>env = <span class="s2">Env</span>.asr(0.01, amp, 0.5);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(out, <span class="s2">Pan2</span>.ar(</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">Formant</span>.ar(freq + detune, ffreq, 30, <span class="s2">EnvGen</span>.kr(env, gate, doneAction:2)), <span class="s2">Rand</span>(-1.0, 1.0))</p>
<p class="p7"><span class="Apple-tab-span">	</span>)</p>
<p class="p7">}).store;</p>
<p class="p3"><br></p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p7">~out.play;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">~out = <span class="s2">Pbind</span>(<span class="s4">\instrument</span>, <span class="s4">\who</span>, <span class="s4">\freq</span>, [600, 601], <span class="s4">\ffreq</span>, 800, <span class="s4">\legato</span>, 0.02);</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// embed a control node proxy into an event pattern:</p>
<p class="p9">// this does not work for indirect assignment as \degree, \midinote, etc.,<span class="Apple-converted-space"> </span></p>
<p class="p9">// because there is calculations in the event! if needed, these can be done in the SynthDef.</p>
<p class="p3"><br></p>
<p class="p7">~lfo = { <span class="s2">SinOsc</span>.kr(2, 0, 400, 700) };</p>
<p class="p7">~out = <span class="s2">Pbind</span>(<span class="s4">\instrument</span>, <span class="s4">\who</span>, <span class="s4">\freq</span>, 500, <span class="s4">\ffreq</span>, ~lfo, <span class="s4">\legato</span>, 0.02);</p>
<p class="p3"><br></p>
<p class="p7">~lfo = { <span class="s2">SinOsc</span>.kr(<span class="s2">SinOsc</span>.kr(0.2, Rand(0,pi), 10, 10), 0, 400, 700) };</p>
<p class="p3"><br></p>
<p class="p7">~lfo = { <span class="s2">LFNoise1</span>.kr(5, 1300, 1500) };</p>
<p class="p7">~lfo = { <span class="s2">MouseX</span>.kr(100, 5500, 1) };</p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7">~out = <span class="s2">Pbind</span>(</p>
<p class="p14"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>\instrument<span class="s3">, </span>\who<span class="s3">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\freq</span>, <span class="s2">Pseq</span>([500, 380, 300],<span class="s2">inf</span>),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\legato</span>, 0.1,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\ffreq</span>, <span class="s2">Pseq</span>([~lfo, 100, ~lfo, 100, 300, 550], <span class="s2">inf</span>), <span class="s5">// use it in a pattern</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\dur</span>, <span class="s2">Pseq</span>([1, 0.5, 0.75, 0.125]*0.4, <span class="s2">inf</span>)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>);</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p9">// note that when you use a proxy within a non-event pattern it gets embedded as an object,</p>
<p class="p9">// so this functionality is still standard</p>
<p class="p3"><br></p>
<p class="p9">// works only with control rate proxies. multichannel control rate proxies cause</p>
<p class="p9">// multichannel expansion of the events:</p>
<p class="p3"><br></p>
<p class="p7">~lfoStereo = { <span class="s2">LFNoise1</span>.kr([1, 1], 1300, 1500) }; <span class="s5">// 2 channel control rate proxy</span></p>
<p class="p7">~out = <span class="s2">Pbind</span>(<span class="s4">\instrument</span>, <span class="s4">\who</span>, <span class="s4">\ffreq</span>, ~lfoStereo, <span class="s4">\legato</span>, 0.02).trace;</p>
<p class="p7">~lfoStereo = { [<span class="s2">MouseX</span>.kr(100, 15500, 1), <span class="s2">SinOsc</span>.kr(<span class="s2">SinOsc</span>.kr(0.2, 0, 10, 10), 0, 400, 700)] }</p>
<p class="p3"><br></p>
<p class="p9">// btw: setting the clock will cause the pattern to sync:</p>
<p class="p7">p.clock = <span class="s2">TempoClock</span>.default;</p>
<p class="p7">p.clock.tempo = 2.0;</p>
<p class="p7">p.clock.tempo = 1.0</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// patterns also crossfade, if an \amp arg is defined in the synthdef:</p>
<p class="p9">// (evaluate a couple of times)</p>
<p class="p7">~out.fadeTime = 3.0;</p>
<p class="p7">(</p>
<p class="p7">~out = <span class="s2">Pbind</span>(</p>
<p class="p14"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>\instrument<span class="s3">, </span>\who<span class="s3">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\freq</span>, <span class="s2">Pshuf</span>([500, 380, 200, 510, 390, 300, 300],<span class="s2">inf</span>) * rrand(1.0, 2.0),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\legato</span>, 0.1,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\ffreq</span>, <span class="s2">Pshuf</span>([~lfo, 100, ~lfo, 100, 300, 550], <span class="s2">inf</span>),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\dur</span>, 0.125 * [1, 2, 3, 2/3].choose</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>);</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">using instruments and players</span></p>
<p class="p3"><br></p>
<p class="p9">// pause and resume do not work yet.</p>
<p class="p6"><br></p>
<p class="p3"><br></p>
<p class="p9">// store an instrument</p>
<p class="p7">(</p>
<p class="p8">Instr<span class="s3">(</span><span class="s4">\test</span><span class="s3">,<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ <span class="s2">arg</span> dens=520, ffreq=7000; <span class="s2">Ringz</span>.ar(<span class="s2">Dust</span>.ar(dens, [1,1]*0.1), ffreq, 0.02) }</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>);</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p7">~out = <span class="s2">Patch</span>(<span class="s4">\test</span>, [10, rrand(5000, 8000)]);</p>
<p class="p7">~out.fadeTime = 3;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7">~out = <span class="s2">InstrSpawner</span>({ <span class="s2">arg</span> freq=1900,env,pan;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Pan2</span>.ar(<span class="s2">SinOsc</span>.ar(freq, 0.5pi, 0.3) * <span class="s2">EnvGen</span>.kr(env, doneAction: 2), pan)</p>
<p class="p7">},[</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Prand</span>([1500, 700, 800, 3000] + 170.rand2, <span class="s2">inf</span>),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Env</span>.perc(0.002,0.01),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Prand</span>([-1,1],<span class="s2">inf</span>)</p>
<p class="p7">],0.125)</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p7">~out.clear;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// does not work (yet).</p>
<p class="p9">//~out.set(\dens, 120);</p>
<p class="p9">//~out.xset(\dens, 1030);<span class="Apple-converted-space"> </span></p>
<p class="p9">//~out.unmap(\ffreq);</p>
<p class="p9">//~out.set(\ffreq, 500);</p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p11">___________________________________________________________________</p>
<p class="p12">client side routines</p>
<p class="p13"><br></p>
<p class="p5"><span class="s1">spawning</span><span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p7">~out.play;</p>
<p class="p9"><span class="s3">~out.awake = false; </span>// allow sound object assignment without immediate sending</p>
<p class="p3"><br></p>
<p class="p9">// putting an synthdef into the node proxy without playing it right away</p>
<p class="p9">// the synthdef has an envelope that frees by itself.</p>
<p class="p7">(</p>
<p class="p7">~out = <span class="s2">SynthDef</span>(<span class="s8">"a"</span>, { <span class="s2">arg</span> out=0, freq=800, pmf=1.0, pan;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">var</span> env, u;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>env = <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.perc(0.001, 0.04, 0.4),doneAction:2); <span class="s5">// envelope</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>u = <span class="s2">SinOsc</span>.ar(freq * <span class="s2">Rand</span>(0.9, 1.1), <span class="s2">SinOsc</span>.ar(pmf, 0, pi), env);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(out, <span class="s2">Pan2</span>.ar(u, pan))</p>
<p class="p7"><span class="Apple-tab-span">	</span>})</p>
<p class="p7">);</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// create a task to repeatedly send grains</p>
<p class="p7">(</p>
<p class="p7">t = <span class="s2">Task</span>.new({</p>
<p class="p7"><span class="Apple-tab-span">	</span>loop({</p>
<p class="p9"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// starts a synth with the current synthdef at index 0</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>~out.spawn([<span class="s4">\pmf</span>, [1, 20, 300].choose, <span class="s4">\pan</span>, [0, -1, 1].choose]);<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[0.1, 0.01, 0.25].choose.wait;</p>
<p class="p7"><span class="Apple-tab-span">	</span>})</p>
<p class="p7">});</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p7">t.start;</p>
<p class="p7">t.stop;</p>
<p class="p7">t.start;</p>
<p class="p3"><br></p>
<p class="p9">// note: if you want to avoid using interpreter variables (single letter, like "t"),</p>
<p class="p9">// you can use Tdef for this. (see Tdef.help)</p>
<p class="p3"><br></p>
<p class="p9">// set some argument</p>
<p class="p7">~out.set(<span class="s4">\freq</span>, 300);</p>
<p class="p7">~out.set(<span class="s4">\freq</span>, 600);</p>
<p class="p7">~out.map(<span class="s4">\freq</span>, ~lfo);</p>
<p class="p7">~lfo = { SinOsc.kr(0.1, 0, 3000, 4000) };</p>
<p class="p7">~lfo = { SinOsc.kr(0.1, 0, 600, 700) };</p>
<p class="p7">~lfo.add({ Trig.kr(Dust.kr(1), 0.1) * 3000 });</p>
<p class="p7">~lfo = 300;</p>
<p class="p3"><br></p>
<p class="p9">// change the definition while going along</p>
<p class="p7">(</p>
<p class="p7">~out = SynthDef("a", { <span class="s2">arg</span> out, freq=800;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">var</span> env;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>env = <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.perc(0.01, 0.1, 0.3),doneAction:2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Out.ar(out, <span class="s2">Pulse</span>.ar(freq * <span class="s2">Rand</span>([0.9,0.9], 1.1), 0.5, env) )</p>
<p class="p7"><span class="Apple-tab-span">	</span>});</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">t.stop;</p>
<p class="p9"><span class="s3">~out.awake = </span><span class="s2">true</span><span class="s3">; </span>// don't forget this</p>
<p class="p9">//<span class="Apple-converted-space">  </span>free all synths in this current ProxySpace</p>
<p class="p7">currentEnvironment.clear;</p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p5"><span class="s1">granular synthesis: efficient code</span></p>
<p class="p3"><br></p>
<p class="p15">see also [jitlib_efficiency]</p>
<p class="p3"><br></p>
<p class="p7">~out.play;</p>
<p class="p13"><br></p>
<p class="p7">(</p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s8">"grain"</span>, { <span class="s2">arg</span> i_out = 0, pan;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">var</span> env;</p>
<p class="p7"><span class="Apple-tab-span">	</span>env = <span class="s2">EnvGen</span>.kr(<span class="s2">Env</span>.perc(0.001, 0.003, 0.2),doneAction:2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">Out</span>.ar(i_out, Pan2.ar(<span class="s2">FSinOsc</span>.ar(<span class="s2">Rand</span>(1000,10000)), pan) * env)<span class="Apple-converted-space"> </span></p>
<p class="p7">}).send(s);</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p9">// a target for the grains</p>
<p class="p9"><span class="s3">~someInput.ar(2);<span class="Apple-converted-space">  </span></span>// initialize to 2 channels audio</p>
<p class="p7">~out = ~someInput;</p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7">t = <span class="s2">Task</span>({</p>
<p class="p7"><span class="Apple-tab-span">	</span>loop({</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>s.sendMsg(<span class="s8">"/s_new"</span>,<span class="s8">"grain"</span>,-1,0,0,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s4">\i_out</span><span class="s3">, ~someInput.index, </span>// returns the bus index of the proxy</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">\pan</span>, [1, 1, -1].choose * 0.2</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>); <span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[0.01, 0.02].choose.wait;</p>
<p class="p7"><span class="Apple-tab-span">	</span>})</p>
<p class="p7">});</p>
<p class="p7">)</p>
<p class="p7">t.play;</p>
<p class="p3"><br></p>
<p class="p9">// different filters;</p>
<p class="p6"><br></p>
<p class="p7">~out.fadeTime = 1.0;</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">BPF</span>.ar(~someInput.ar, <span class="s2">MouseX</span>.kr(100, 18000, <span class="s4">1</span>), 0.1) };</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">CombL</span>.ar(~someInput.ar * (<span class="s2">LFNoise0</span>.ar(2) &gt; 0), 0.2, 0.2, <span class="s2">MouseX</span>.kr(0.1, 5, 1)) };</p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">RLPF</span>.ar(~someInput.ar, <span class="s2">LFNoise1</span>.kr(3, 1000, 1040), 0.05) };</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">t.stop;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">//_________</p>
<p class="p3"><br></p>
<p class="p7">~out.stop;</p>
<p class="p7">currentEnvironment.clear;</p>
<p class="p9"><span class="s2">ProxySpace</span><span class="s3">.pop; </span>// restore original environment</p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p11">________________________________________________________________________</p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p5"><span class="s1">using multiple proxyspaces</span></p>
<p class="p5">note that this can be done while the server is not running: with p.wakeUp or p.play</p>
<p class="p5">the environment can be played back.</p>
<p class="p13"><br></p>
<p class="p9">// quit server:</p>
<p class="p3"><br></p>
<p class="p7">s.quit;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// create two proxyspaces without a running server</p>
<p class="p7">(</p>
<p class="p8"><span class="s3">p = </span>ProxySpace<span class="s3">(s);</span></p>
<p class="p8"><span class="s3">q = </span>ProxySpace<span class="s3">(s);</span></p>
<p class="p3"><br></p>
<p class="p7">p.use({</p>
<p class="p7"><span class="Apple-tab-span">	</span>~out = { <span class="s2">Resonz</span>.ar(~in.ar, ~freq.kr, 0.01) };</p>
<p class="p7"><span class="Apple-tab-span">	</span>~in = { <span class="s2">WhiteNoise</span>.ar(0.5) };</p>
<p class="p7"><span class="Apple-tab-span">	</span>~freq = { <span class="s2">LFNoise2</span>.kr(1, 1000, 2000) };</p>
<p class="p7">});</p>
<p class="p3"><br></p>
<p class="p7">q.use({</p>
<p class="p3"><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>~in = { <span class="s2">Dust</span>.ar(20, 0.1) };</p>
<p class="p7"><span class="Apple-tab-span">	</span>~out = { <span class="s2">Resonz</span>.ar(~in.ar * 450, ~freq.kr, 0.005) };</p>
<p class="p7"><span class="Apple-tab-span">	</span>~freq = { <span class="s2">LFNoise2</span>.kr(1, 400, 2000) };</p>
<p class="p7">});</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p9">// wait for the booted<span class="Apple-converted-space">  </span>server</p>
<p class="p7">s.boot;</p>
<p class="p3"><br></p>
<p class="p9">// play the proxy at \out</p>
<p class="p7">p.play(<span class="s4">\out</span>);<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s3">q.play; </span>// out is the default output</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">external access</span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">q[\in][1] = { Impulse.ar(2, 0, 0.5) }; <span class="s5">// adding a synth at index 1</span></p>
<p class="p3"><br></p>
<p class="p9">// equivalent to</p>
<p class="p7">q.at(\in).put(1, { Impulse.ar(7, 0, 0.5) });</p>
<p class="p4"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">connecting two spaces</span> (must be on one server)</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">(</p>
<p class="p7">q.use({</p>
<p class="p7"><span class="Apple-tab-span">	</span>~freq =<span class="Apple-converted-space">  </span>100 + p[<span class="s4">\freq</span>] / 2;</p>
<p class="p7">})</p>
<p class="p7">)</p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">recording output</span> (see also: [RecNodeProxy])</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">r = p.record(<span class="s4">\out</span>, <span class="s8">"proxySpace.aiff"</span>);</p>
<p class="p3"><br></p>
<p class="p9">// start recording</p>
<p class="p7">r.unpause;</p>
<p class="p3"><br></p>
<p class="p9">// pause recording</p>
<p class="p7">r.pause;</p>
<p class="p3"><br></p>
<p class="p9">// stop recording</p>
<p class="p7">r.close;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">push/pop</span></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// make x the currentEnvironment</p>
<p class="p7">p.push;<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p7">~freq = 700;</p>
<p class="p7">~freq = 400;</p>
<p class="p7">~freq = { p.kr(<span class="s4">\freq</span>) + LFNoise1.kr(1, 200, 300) % 400 }; // feedback</p>
<p class="p7">~freq = 400;</p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">p.pop; </span>// restore environment</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// make y the currentEnvironment</p>
<p class="p7">q.push;<span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p7">~freq = 1000;</p>
<p class="p7">~in = { <span class="s2">WhiteNoise</span>.ar(0.01) };</p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">q.pop; </span>// restore environment</p>
<p class="p3"><br></p>
<p class="p7">q.clear;</p>
<p class="p7">p.clear;</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">______________________________________________________________</p>
<p class="p3"><br></p>
<p class="p5"><span class="s1">some more topics</span></p>
<p class="p3"><br></p>
<p class="p5">nodeproxy with numbers as input:</p>
<p class="p3"><br></p>
<p class="p7">p = <span class="s2">ProxySpace</span>.push(s.boot);</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p7">~out = { <span class="s2">SinOsc</span>.ar(~a.kr * Rand(1, 2), 0, 0.1) };</p>
<p class="p7">~out.play;</p>
<p class="p3"><br></p>
<p class="p7">~a = 900;</p>
<p class="p3"><br></p>
<p class="p9">// these add up:</p>
<p class="p7">~a[0] = 440;</p>
<p class="p7">~a[1] = 220;</p>
<p class="p7">~a[2] = 20;</p>
<p class="p3"><br></p>
<p class="p7">~a.fadeTime = 2;</p>
<p class="p3"><br></p>
<p class="p9"><span class="s3">~a[0] = 300; </span>// now there is a crossfade.</p>
<p class="p7">~a[1] = { <span class="s2">SinOsc</span>.kr(5, 0, 20) };<span class="Apple-converted-space"> </span></p>
<p class="p7">~a[2] = { <span class="s2">SinOsc</span>.kr(30, 0, 145) };</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p9">// internally a numerical input is approximately replaced by:</p>
<p class="p9">// (pseudocode)</p>
<p class="p7"><span class="s2">SynthDef</span>(<span class="s8">"name"</span>, { <span class="s2">arg</span> out, fadeTime;</p>
<p class="p7"><span class="Apple-tab-span">	</span> <span class="s2">Out</span>.kr(out,</p>
<p class="p7"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span><span class="s2">Control</span>.kr(<span class="s2">Array</span>.fill(proxy.numChannels, { the number }))<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>* <span class="s2">EnvGate</span>.new(fadeTime:fadeTime)</p>
<p class="p7"><span class="Apple-tab-span">	</span> )<span class="Apple-converted-space"> </span></p>
<p class="p7">});</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
</body>
</html>
