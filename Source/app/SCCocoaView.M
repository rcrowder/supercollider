/*
    SCCocoaView.M

    Created by falkenst on Tue Feb 08 2005.
    Copyright (c) 2005 jan truetzschler. All rights reserved.
 
	SuperCollider real time audio synthesis system
    Copyright (c) 2002 James McCartney. All rights reserved.
	http://www.audiosynth.com

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <Cocoa/Cocoa.h>
#include <Carbon/Carbon.h>
#include <pthread.h>
#include "PyrPrimitive.h"
#include "PyrObject.h"
#include "PyrKernel.h"
#include "GC.h"
#include "VMGlobals.h"
#include "SC_RGen.h"
#include "SC_BoundsMacros.h"
#include "SC_InlineBinaryOp.h"
#include "PyrListPrim.h"


#include "SCCocoaView.h"
#include "QuickTime/Movies.h"
#import "HTMLRenderer.h"
#import "MyDocument.h"
#import "SCImage.h"

extern pthread_mutex_t gLangMutex;
extern bool compiledOK;

// SCImage support
extern PyrSymbol		*s_scimage; // class symbol
extern PyrObject*		newPyrSCImage(VMGlobals* g); // class creation func

void SyntaxColorize(NSTextView* textView);

@implementation SCCocoaTextViewResponder

- (struct PyrObject*)getSCObject
{
	return mSCViewObject->GetSCObj();
}
- (void)textDidEndEditing:(NSNotification *)aNotification
{
//	post("endEditing");
}
- (void)textDidBeginEditing:(NSNotification *)aNotification
{
}

- (void)setSCView: (struct SCCocoaTextView*)inObject
{
	mSCViewObject = inObject;
}
	

- (IBAction) executeSelection: (id) sender
{
	if(enterExecutesSelection)
    [self sendSelection: "interpretPrintCmdLine" ];
}

- (void)sendSelection: (char*) methodName
{        
    if (!compiledOK) {
        return;
    }

	NSRange selectedRange;
	SCTextView * txtView = mSCViewObject->getTextView();
	NSString* selection = [txtView currentlySelectedTextOrLine: &selectedRange];
    const char *text = [selection UTF8String];
	int textlength = strlen(text);

    [[SCVirtualMachine sharedInstance] setCmdLine: text length: textlength];
    
    NSRange newSelectedRange = NSMakeRange(selectedRange.location + selectedRange.length, 0);
    [txtView setSelectedRange: newSelectedRange];
    
    pthread_mutex_lock(&gLangMutex);
    runLibrary(getsym(methodName));
    pthread_mutex_unlock(&gLangMutex);
    
}

- (void) keyDown: (NSEvent*) event
{
	// for some reason modifiers becomes 256 on my machine with no keys pressed. So need to mask against known keys.
		if(usesTabToFocusNextView){
		    NSString *characters = [event characters];
			unsigned int modifiers = [event modifierFlags];	
			uint32 allKnownModifiers = NSAlphaShiftKeyMask | NSShiftKeyMask | NSControlKeyMask | NSCommandKeyMask 
				| NSAlternateKeyMask | NSHelpKeyMask | NSFunctionKeyMask;
			unichar character = 0;
			if([characters length] > 0) {
				character = [characters characterAtIndex: 0];
			}				
			if(character == 9 && ((modifiers & allKnownModifiers) == 0)) {
			   mSCViewObject->tabPrevFocus(); //this does not work as expected!
				return;
			} else if (character == 25 && ((modifiers & allKnownModifiers) == NSShiftKeyMask)) {
				mSCViewObject->tabNextFocus();
				return;
			} // other tab keys avail for user 
		}

}
- (void) keyUp: (NSEvent*) event
{

}
- (void) mouseDown: (NSEvent*) event
{
	mSCViewObject->makeFocus(true);
}
- (void) setUsesTabToFocusNextView: (BOOL) flag
{
	usesTabToFocusNextView = flag;
}

- (void) setEnterExecutesSelection: (BOOL) flag
{
	enterExecutesSelection = flag;
}

- (BOOL) textView: (NSTextView *) textView
    clickedOnLink: (id) link
		  atIndex: (unsigned) charIndex
{
    NSDocumentController* docctl = [NSDocumentController sharedDocumentController];
	if (!docctl) return YES;
	
	NSURL *desiredURL;
	
	// is it a NSURL link or a NSString link?
	if ([link isKindOfClass: [NSString class]])
    {
		if([link hasPrefix:@"SC://"] || [link hasPrefix:@"sc://"]) { // this means search immediately
			NSString *helpPath = pathOfHelpFileFor([[[link substringFromIndex:5] stringByDeletingPathExtension] stringByDeletingPathExtension]);
			if(!helpPath) {
				post("WARNING:\nInvalid hyperlink: '%s' Please repair this.\n", [link cString]);
				return YES;
			}
			desiredURL = [NSURL URLWithString: helpPath];
		} //else desiredURL = [NSURL URLWithString: [link stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding] relativeToURL: [self fileURL]];
        
    } else if ([link isKindOfClass: [NSURL class]])
    {
		
		// check for schemes which we'll handle
		if([[link scheme] isEqualToString: @"SC"] || [[link scheme] isEqualToString:@"sc"]) { // this means search immediately
			
			NSString *helpPath = pathOfHelpFileFor([[[[link relativeString] substringFromIndex:5] stringByDeletingPathExtension] stringByDeletingPathExtension]);
			if(!helpPath) {
				post("WARNING:\nInvalid hyperlink: '%s' Please repair this.\n", [[link relativeString] cString]);
				return YES;
			}
			desiredURL = [NSURL fileURLWithPath: helpPath];
		} else if (![link scheme]) { // NULL could be a regular file link that's been edited
			if([[link relativePath] hasPrefix: @"/"]) {
				desiredURL = [NSURL fileURLWithPath: [link relativeString]];
			} //else {
//				desiredURL = [NSURL URLWithString: [[link relativeString] stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding] relativeToURL: [self fileURL]];
//			}
			//desiredURL = [NSURL fileURLWithPath: [link relativeString]];
		} else if(![[link scheme] isEqualToString: @"file"]) {
			return NO; // it's http, etc. so pass it on to Safari or whatever
		} else desiredURL = link; // it's a regular file:// URL
    } else return NO;
    
	MyDocument *doc = nil;
	if([[NSFileManager defaultManager] fileExistsAtPath: [desiredURL path]]) {
		
		doc = (MyDocument*)[docctl documentForURL: [desiredURL absoluteURL]];
	} else NSLog(@"file doesn't exist at path");
    if (!doc) {
        doc = [docctl openDocumentWithContentsOfURL: desiredURL display: true];
        if (!doc) {
			// it's a bad file:// URL, post a warning and search
			post("WARNING:\nInvalid hyperlink: '%s' Please repair this.\nSearching help directories for alternative.\n", [[desiredURL path] cString]);
			// delete extension twice in case something.help.rtf
			NSString *desiredHelpName = [[[[desiredURL path] lastPathComponent] stringByDeletingPathExtension] stringByDeletingPathExtension];
			NSString *helpPath = pathOfHelpFileFor(desiredHelpName); 
			if(!helpPath) {
				post("Can't find Help File Document for: '%s'\n", [desiredHelpName cString]);
				return YES;
			}
			desiredURL = [NSURL fileURLWithPath: helpPath];
			if([[NSFileManager defaultManager] fileExistsAtPath: [desiredURL path]]) {
				doc = (MyDocument*)[docctl documentForURL: [desiredURL absoluteURL]];
			} else post("file doesn't exist at path: '%s'\n", [[desiredURL path] cString]);
			if (!doc) {
				doc = [docctl openDocumentWithContentsOfURL: desiredURL display: true];
				if(!doc) {
					post("Can't open Help File Document: '%s'\n", [[desiredURL path] cString]);
					return YES;
				}
			}
        }
    }
    NSWindow *window = [[[doc windowControllers] objectAtIndex: 0] window];
    if (!window) {
        post("!! window controller returns nil ? failed to open help file window\n");
        return YES;
    }
    [window makeKeyAndOrderFront: nil];
    return YES;
}

@end

@implementation SCNSMenuItem

- (void)setSCObject: (struct PyrObject*)inObject
{
    mMenuItemObj = inObject;
}

- (struct PyrObject*)getSCObject
{
    return mMenuItemObj;
}

- (void)doAction: (id)sender
{
	//	post("doAction \n");
    pthread_mutex_lock (&gLangMutex);	
	PyrObject * pobj = [self getSCObject];
	if(compiledOK && pobj){
		PyrSymbol *method = getsym("doAction");
		VMGlobals *g = gMainVMGlobals;
		g->canCallOS = true;
		++g->sp;  SetObject(g->sp, pobj); 
		++g->sp;  SetInt(g->sp, 1); 
		runInterpreter(g, method, 2);
		g->canCallOS = false;
	}
    pthread_mutex_unlock (&gLangMutex);	
}

@end

NSRect SCtoNSRect(SCRect screct);

SCView* NewSCCocoaTextView(SCContainerView *inParent, PyrObject* inObj, SCRect inBounds)
{
	return new SCCocoaTextView(inParent, inObj, inBounds);
}

SCCocoaTextView::SCCocoaTextView(SCContainerView *inParent, PyrObject* inObj, SCRect inBounds)
	: SCView(inParent, inObj, inBounds)
{

	NSRect matrect = SCtoNSRect(getDrawBounds());
	mTextView = [[SCTextView alloc] initWithFrame:matrect];
	NSView *view = mTop->GetNSView();		
	mCocoaToLangAction = [SCCocoaTextViewResponder alloc];
	[mCocoaToLangAction setSCView: this];
    [mTextView setAutoresizingMask: 63];
    [[mTextView textContainer] setWidthTracksTextView: YES];
    [mTextView setAllowsUndo: YES];
    [mTextView setRichText: YES];
    [mTextView setSmartInsertDeleteEnabled: NO];
    [mTextView setImportsGraphics: YES];
    [mTextView setFont: [NSFont fontWithName: @"Monaco" size: 9]];
	[mTextView setSelectedRange: NSMakeRange(0,0)];
	[mTextView setLangClassToCall:@"SCView" 
			withKeyDownActionIndex:1 withKeyUpActionIndex:2];
	[mTextView  setObjectKeyDownActionIndex:4 setObjectKeyUpActionIndex:5];	
	mScrollView = [[NSScrollView alloc] initWithFrame: matrect];
	[mScrollView setDocumentView: mTextView];
	[mTextView setDelegate: mCocoaToLangAction];
	[view addSubview: mScrollView];
	[[mTextView textContainer] setContainerSize:NSMakeSize([mScrollView contentSize].width, FLT_MAX)];
	//This is a hack, otherwise the mTextView always has focus even if makeFirstResponder: view is called...
	[mTextView setAcceptsFirstResponder:NO];
	[mScrollView setDrawsBackground:YES];
	[mCocoaToLangAction setUsesTabToFocusNextView:YES];
	[mCocoaToLangAction setEnterExecutesSelection:YES];	
//	[mTextView autorelease];
//	[mScrollView autorelease];
	
	setVisibleFromParent();
}

SCCocoaTextView::~SCCocoaTextView()
{
	[mScrollView removeFromSuperview];
	[mCocoaToLangAction release];
	[mTextView release];
	[mScrollView release];
}

void SCCocoaTextView::tabPrevFocus()
{
	mTop->tabPrevFocus();
}
void SCCocoaTextView::tabNextFocus()
{
	//post("next focus\n");
	mTop->tabNextFocus();
}
void SCCocoaTextView::makeFocus(bool focus)
{
    if (focus) {
        if (canFocus() && !isFocus()) {
			[mTextView setAcceptsFirstResponder:YES];
			[[mTextView window] makeFirstResponder: mTextView];	
        }
    } else {
        if (isFocus()) {
			if([[mTextView window] firstResponder] == mTextView)
				[[mTextView window] makeFirstResponder: mTop->GetNSView()];	
			[mTextView setAcceptsFirstResponder:NO];
        }
    }
	SCView::makeFocus(focus);
}


int slotGetSCRect(PyrSlot* a, SCRect *r);
extern PyrSymbol *s_font;
int slotBackgroundVal(PyrSlot *slot, DrawBackground **ioPtr);

void SCCocoaTextView::setBounds(SCRect inBounds)
{
		mBounds = inBounds;
		[[mScrollView superview] setNeedsDisplayInRect:[mScrollView frame]];
		if(mParent->relativeOrigin()){
			SCRect pbounds = mParent->getLayout().bounds; 	// relative origin fix
			mLayout.bounds.x = mBounds.x + pbounds.x;
			mLayout.bounds.y = mBounds.y + pbounds.y;
			mLayout.bounds.width = mBounds.width;
			mLayout.bounds.height = mBounds.height;	
		} else {
			mLayout.bounds = mBounds;
		}
		[mScrollView setFrame: SCtoNSRect(mLayout.bounds)];
		[mTextView setFrame: SCtoNSRect(mLayout.bounds)]; // not needed - br

	//	[mScrollView setBounds: SCtoNSRect(mBounds)];
	//	[mTextView setBounds: SCtoNSRect(mBounds)];
	//	[mScrollView setNeedsDisplay: YES]; // not needed - br
	//	[mTextView setNeedsDisplay: YES];	// not needed - br
}

void SCCocoaTextView::keyDown(int character, int modifiers, unsigned short keycode)
{
}

void SCCocoaTextView::keyUp(int character, int modifiers, unsigned short keycode)
{
}


int slotColorVal(PyrSlot *slot, SCColor *sccolor);
int setSlotColor(PyrSlot *slot, SCColor *sccolor);

int SCCocoaTextView::setProperty(PyrSymbol *symbol, PyrSlot *slot)
{	
	int err;
	char *name = symbol->name;

	if (strcmp(name, "visible")==0) {
		bool visible = IsTrue(slot);
		mVisible = visible;
		setVisibleFromParent();
		return errNone;
	}
	
	if (strcmp(name, "usesTabToFocusNextView")==0) {
		if(IsTrue(slot))[mCocoaToLangAction setUsesTabToFocusNextView:YES];
		else [mCocoaToLangAction setUsesTabToFocusNextView:NO];
		return errNone;		
	}
	if (strcmp(name, "enterExecutesSelection")==0) {
		if(IsTrue(slot))[mCocoaToLangAction setEnterExecutesSelection:YES];
		else [mCocoaToLangAction setEnterExecutesSelection:NO];
		return errNone;		
	}	
	if (strcmp(name, "setScrollersSize")==0) {
		if(IsTrue(slot)) [[mScrollView verticalScroller] setControlSize: NSMiniControlSize];
		else  [mScrollView setAutohidesScrollers:NO];
		[mScrollView setNeedsDisplay: YES];
		return errNone;

	}
	
	if (strcmp(name, "setAutohidesScrollers")==0) {
		if(IsTrue(slot)) [mScrollView setAutohidesScrollers:YES];
		else  [mScrollView setAutohidesScrollers:NO];
		[mScrollView setNeedsDisplay: YES];		
		return errNone;

	}
	
	if (strcmp(name, "setHasHorizontalScroller")==0) {
		if(IsTrue(slot)) [mScrollView setHasHorizontalScroller:YES];
		else  [mScrollView setHasHorizontalScroller:NO];
		[mScrollView setNeedsDisplay: YES];
		return errNone;
		
	}
	
	if (strcmp(name, "setHasVerticalScroller")==0) {
		if(IsTrue(slot)) [mScrollView setHasVerticalScroller:YES];
		else  [mScrollView setHasVerticalScroller:NO];
		[mScrollView setNeedsDisplay: YES];
		return errNone;		
	}	
	if (strcmp(name, "setEditable")==0) {
		if(IsTrue(slot)) [mTextView setEditable:YES];
		else  [mTextView setEditable:NO];
		return errNone;		
	}		
	if (strcmp(name, "bounds")==0) {
		SCRect screct;
		//add avariable to choos if this should resize the textview too
		err = slotGetSCRect(slot, &screct);
		if (err) return err;

		setBounds(screct);
	
		return errNone;
	}
	
	if (strcmp(name, "textBounds")==0) {
		SCRect screct;
		err = slotGetSCRect(slot, &screct);
		if (err) return err;
		[[mScrollView superview] setNeedsDisplayInRect:[mScrollView frame]];
		//mBounds = screct;

		[mTextView setFrame: SCtoNSRect(screct)];

	//	[mScrollView setBounds: SCtoNSRect(mBounds)];
	//	[mTextView setBounds: SCtoNSRect(mBounds)];
		[mScrollView setNeedsDisplay: YES];
		[mTextView setNeedsDisplay: YES];
	
		return errNone;
	}
	if (strcmp(name, "selectedString")==0) {
		if(!isKindOfSlot(slot, class_string)) return errWrongType;
		PyrString* pstring = slot->uos;
		if(!pstring) return errNone;
		NSRange selectedRange = [mTextView selectedRange];
		NSString *string = [[NSString alloc] initWithCString: pstring->s length: pstring->size];
		if ([mTextView shouldChangeTextInRange: selectedRange replacementString: string]) {
			[mTextView replaceCharactersInRange: selectedRange withString: string];
			[mTextView didChangeText];
		}
		[string release];
		return errNone;
	}
	
	if (strcmp(name, "open")==0) {
		if(!isKindOfSlot(slot, class_string)) return errWrongType;
		PyrString* pstring = slot->uos;
		if(!pstring) return errNone;
		NSRange selectedRange = [mTextView selectedRange];
		NSString *path = [[NSString alloc] initWithCString: pstring->s length: pstring->size];
		NSURL *url = [NSURL fileURLWithPath: path];
		
		NSTextStorage* text = [mTextView textStorage];
		
		[text beginEditing];	// Bracket with begin/end editing for efficiency
		[[text mutableString] setString:@""];	// Empty the document
		
		NSString* extension = [path pathExtension];
		
		if ([extension isEqualToString: @"html"] || [extension isEqualToString: @"htm"]) {
			NSAttributedString *htmlAttributedString = [HTMLRenderer attributedStringWithURL:url];
			
			if(!htmlAttributedString) {
				[text endEditing];
				[path release];
				return errFailed;
			} else {
				[text setAttributedString:htmlAttributedString];
				[mTextView setDefaultTabsTo: 28.0f];
			}
		}
		else {
			NSError *error;
			BOOL success = [text readFromURL:url options:nil documentAttributes:nil error:&error];
			if(!success) {
				NSLog(@"Error opening file: %@", error);
				[text endEditing];
				[path release];
				return errFailed;
			}
		}
		
		if ([extension isEqualToString: @"sc"] || [extension isEqualToString: @"scd"]) {
			[mTextView setFont: [NSFont fontWithName: @"Monaco" size: 9]];
			SyntaxColorize(mTextView);
		}
		
		[text endEditing];

		[path release];
		return errNone;
	}
	
	if (strcmp(name, "background")==0) {
		err = slotBackgroundVal(slot, &mBackground);
		if (err) return err;
		SCColor rgb;
		err = slotColorVal(slot, &rgb);
		if (err) return err;
		NSColor *color = [NSColor colorWithCalibratedRed: rgb.red
                            green: rgb.green 
                            blue: rgb.blue 
                            alpha: rgb.alpha];
		[mTextView setBackgroundColor: color];
		[mScrollView setBackgroundColor: color];
		return errNone;
	}	

	if (strcmp(name, "setTextColor")==0) {
		if(!isKindOfSlot(slot, class_array)) return errWrongType;
		PyrSlot *slots = slot->uo->slots;	
		SCColor rgb;
		int rangeStart, rangeSize;
		err = slotColorVal(slots+0, &rgb);
		if (err) return err;
		err = slotIntVal(slots+1, &rangeStart);
		if (err) return err;		
		err = slotIntVal(slots+2, &rangeSize);
		if (err) return err;


		NSColor *color = [NSColor colorWithCalibratedRed: rgb.red
                            green: rgb.green 
                            blue: rgb.blue 
                            alpha: rgb.alpha];
		
		//[[doc textView] setBackgroundColor: color];
		
		if(rangeStart < 0){
			[mTextView setTextColor: color];
			[mTextView didChangeText];
			return errNone;
		}
		int length = [[mTextView string] length];
		if(rangeStart >= length) rangeStart = length - 1 ;
		if(rangeStart + rangeSize >= length) rangeSize = length - rangeStart;
		NSRange selectedRange =	NSMakeRange(rangeStart, rangeSize);
		
		
		[mTextView setTextColor: color range: selectedRange];
		[mTextView didChangeText];
		return errNone;
	}
	
	if (strcmp(name, "setFont")==0) {
		if(!isKindOfSlot(slot, class_array)) return errWrongType;	
		PyrSlot *slots =slot->uo->slots;
		PyrSlot *fontSlot = slots+0;
		if (IsNil(fontSlot)) return errNone; // use default font
		if (!(isKindOfSlot(fontSlot, s_font->u.classobj))) return errWrongType;
		PyrSlot *nameSlot = fontSlot->uo->slots+0;
		PyrSlot *sizeSlot = fontSlot->uo->slots+1;
		float size;
		int err = slotFloatVal(sizeSlot, &size);
		if (err) return err;

		PyrString *pstring = nameSlot->uos;
		NSString *fontName = [NSString stringWithCString: pstring->s length: pstring->size];
		if (!fontName) return errFailed;
		NSFont *font = [NSFont fontWithName: fontName size: size];
		if (!font) return errFailed;
		
		int rangeStart, rangeSize;
		err = slotIntVal(slots+1, &rangeStart); //if -1 do not use range
        if (err) return err;
		 err = slotIntVal(slots+2, &rangeSize);
        if (err) return err;

		if(rangeStart < 0){
			[mTextView setFont: font];
			return errNone;
		}
		NSString* string = [mTextView string];
		int length = [string length];
		if(length < 1) return errFailed;		
		if(rangeStart >= length) rangeStart = length - 1 ;
		if(rangeStart + rangeSize >= length) rangeSize = length - rangeStart;
		NSRange selectedRange =	NSMakeRange(rangeStart, rangeSize);
		
        [mTextView setFont: font range: selectedRange];
		return errNone;
	}
	
//	if (strcmp(name, "insertString")==0) {
//		if (!(isKindOfSlot(slot, class_string))) return errWrongType;
//        PyrString* string = slot->uos;
////        [doc insertText: string->s length: string->size];
//        return errNone;
//	}
	if (strcmp(name, "insertStringInRange")==0) {
		if(!isKindOfSlot(slot, class_array)) return errWrongType;	
		PyrSlot *slots =slot->uo->slots;	
		PyrSlot *stringSlot = slots+0;	
		if (!(isKindOfSlot(stringSlot, class_string))) return errWrongType;

		int rangeStart, rangeSize;
		int err = slotIntVal(slots+1, &rangeStart); //if -1 do not use range
        if (err) return err;
		err = slotIntVal(slots+2, &rangeSize);
        if (err) return err;

		PyrString* pstring = stringSlot->uos;
		NSRange selectedRange;
		int length = [[mTextView string] length];
		
		if(rangeSize < 0) rangeSize = length - 1;
		if(rangeStart >= length) rangeStart = length - 1 ;
		if(rangeStart + rangeSize >= length) rangeSize = length - rangeStart;
		
		if(rangeStart<0) selectedRange =	NSMakeRange(0, length);
		else selectedRange =	NSMakeRange(rangeStart, rangeSize);
		
		NSString *string = [[NSString alloc] initWithCString: pstring->s length: pstring->size];
		BOOL editable = [mTextView isEditable];
		if(!editable) [mTextView setEditable:YES]; //always allow programmatic editing
		
		if ([mTextView  shouldChangeTextInRange: selectedRange replacementString: string]) {
			[mTextView  replaceCharactersInRange: selectedRange withString: string];
			[mTextView  didChangeText];
		}

		if(!editable) [mTextView setEditable:NO];
		
		[string release];
	
        return errNone;
	}
	
	return SCView::setProperty(symbol, slot);
}

int SCCocoaTextView::getProperty(PyrSymbol *symbol, PyrSlot *slot)
{
	char *name = symbol->name;

	if (strcmp(name, "string")==0) {
		NSString* str = [mTextView string];
        const char * cstr = [str UTF8String];
        PyrString *string = newPyrString(NULL, cstr, 0, true);
        SetObject(slot, string);
		return errNone;
	}

	if (strcmp(name, "selectedString")==0) {        
		NSString* str = [mTextView currentlySelectedTextOrLine:NULL];
        const char * cstr = [str UTF8String];
        PyrString *string = newPyrString(NULL, cstr, 0, true);
        SetObject(slot, string);
		return errNone;		
	}

	if (strcmp(name, "selectedRange")==0) {        
		NSRange range = [mTextView selectedRange];
		SetInt(slot, range.length);
		return errNone;
	}

	if (strcmp(name, "selectedRangeLocation")==0) {        	
		NSRange range = [mTextView selectedRange];
		SetInt(slot, range.location);
		return errNone;
	}
	
	return SCView::getProperty(symbol, slot);
}

void SCCocoaTextView::setVisibleFromParent()
{
	if(mVisible && mParent->isVisible()) {
		[mScrollView setHidden:NO];
		[mTextView setHidden:NO];
		return;
	} else {
		[mScrollView setHidden:YES];
		[mTextView setHidden:YES];
	}
	
}




////////////////////
SCView* NewSCMovieView(SCContainerView *inParent, PyrObject* inObj, SCRect inBounds)
{
	return new SCMovieView(inParent, inObj, inBounds);
}

SCMovieView::SCMovieView(SCContainerView *inParent, PyrObject* inObj, SCRect inBounds)
	: SCView(inParent, inObj, inBounds)
{
		NSRect matrect = SCtoNSRect(getDrawBounds());
		mMovieView = [[NSMovieView alloc] initWithFrame:matrect];
		NSView *view = mTop->GetNSView();	
		[view addSubview: mMovieView];
		
		//need to call EnterMovies for other qt c calls
		EnterMovies();
		setVisibleFromParent();
}

SCMovieView::~SCMovieView()
{
	[mMovieView removeFromSuperview];
	[mMovieView release];
}

void SCMovieView::setBounds(SCRect screct)
{
	[[mMovieView superview] setNeedsDisplayInRect:[mMovieView frame]];
	mBounds = screct;
	if(mParent->relativeOrigin()){
		SCRect pbounds = mParent->getLayout().bounds; 	// relative origin fix
		mLayout.bounds.x = mBounds.x + pbounds.x;
		mLayout.bounds.y = mBounds.y + pbounds.y;
		mLayout.bounds.width = mBounds.width;
		mLayout.bounds.height = mBounds.height;	
	} else {
		mLayout.bounds = mBounds;
	}

	[mMovieView setFrame: SCtoNSRect(mLayout.bounds)];
	[mMovieView setBounds: SCtoNSRect(mBounds)]; //?
	[mMovieView setNeedsDisplay: YES];
}

int SCMovieView::setProperty(PyrSymbol *symbol, PyrSlot *slot)
{	
	int err;
	char *name = symbol->name;
	
	if (strcmp(name, "visible")==0) {
		bool visible = IsTrue(slot);
		mVisible = visible;
		setVisibleFromParent();
		return errNone;
	}
	
	if (strcmp(name, "stop")==0) {
		[mMovieView stop: nil];
		return errNone;
	}

	if (strcmp(name, "start")==0) {
		[mMovieView start: nil];
		return errNone;	
	}
	if (strcmp(name, "stepForward")==0) {
		[mMovieView stepForward: nil];
		return errNone;		
	}
	if (strcmp(name, "stepBack")==0) {
		[mMovieView stepBack: nil];
		return errNone;		
	}		
	if (strcmp(name, "resizeWithMagnification")==0) {
		float mag;
		err = slotFloatVal(slot, &mag);
		if(err) return err;
		[mMovieView resizeWithMagnification: mag];
		NSSize size = [mMovieView sizeForMagnification: mag];
		mBounds.width = size.width;
		mBounds.height = size.height;
		return errNone;
	}	
	if (strcmp(name, "bounds")==0) {
		SCRect screct;
		err = slotGetSCRect(slot, &screct);
		if (err) return err;
		setBounds(screct);
		return errNone;
	}
	
	if (strcmp(name, "setMovie")==0) {
		if(!isKindOfSlot(slot, class_string)) return errWrongType;
		PyrString* pstring = slot->uos;
		if(!pstring) return errNone;
		NSString *string = [[NSString alloc] initWithCString: pstring->s length: pstring->size];		
		NSURL * url = [[NSURL alloc] initFileURLWithPath: string];		
		NSMovie *movie = [[NSMovie alloc] initWithURL: url byReference: YES];
		if(!movie) return errFailed;
		//check for current movie:
		NSMovie *nsmovie = [mMovieView movie];
		[mMovieView setMovie: movie];
		if(nsmovie){
			[nsmovie release];
		}
		[string release];
		[url release];
		/* QT: */
		mMovie = (Movie) [[mMovieView movie] QTMovie];
		mTimeBase = GetMovieTimeBase (mMovie); 
		mTimeRecord.base = mTimeBase;
		GetMovieTime(mMovie, &mTimeRecord);
		
		return errNone;
	}

	if (strcmp(name, "setMuted")==0) {
		if(IsTrue(slot))[mMovieView setMuted: YES];
		else [mMovieView setMuted: NO];
		return errNone;		
	}
	
	if (strcmp(name, "setEditable")==0) {
		if(IsTrue(slot))[mMovieView setEditable: YES];
		else [mMovieView setEditable: NO];
		return errNone;		
	}

	if (strcmp(name, "setPlaysSelectionOnly")==0) {
		if(IsTrue(slot))[mMovieView setPlaysSelectionOnly: YES];
		else [mMovieView setPlaysSelectionOnly: NO];
		return errNone;		
	}

	if (strcmp(name, "setRate")==0) {
		float rate;
		err = slotFloatVal(slot, &rate);
		if(err) return err;
		[mMovieView setRate:rate];
		return errNone;		
	}
	if (strcmp(name, "setVolume")==0) {
		float vol;
		err = slotFloatVal(slot, &vol);
		if(err) return err;
		[mMovieView setVolume:vol];
		return errNone;		
	}
	if (strcmp(name, "setLoopMode")==0) {
		int mode;
		err = slotIntVal(slot, &mode);
		if(err) return err;
		switch(mode){
				case 0: [mMovieView setLoopMode:NSQTMovieLoopingBackAndForthPlayback]; break;
				case 1: [mMovieView setLoopMode:NSQTMovieLoopingPlayback]; break;
				case 2: [mMovieView setLoopMode:NSQTMovieNormalPlayback]; break;
		}
		return errNone;		
	}
	
	if (strcmp(name, "gotoEnd")==0) {
		[mMovieView gotoEnd: NULL];
		return errNone;		
	}

	if (strcmp(name, "gotoBeginning")==0) {
		[mMovieView gotoBeginning: NULL];
		return errNone;		
	}	
	
	if (strcmp(name, "showControllerAndAdjustSize")==0) {
		if(!isKindOfSlot(slot, class_array)) return errWrongType;
		PyrSlot *slots = slot->uo->slots;
		BOOL showC, adjust;
		if(IsTrue(slots+0)) showC=YES;
		else showC = NO;
		if(IsTrue(slots+1)) adjust=YES;
		else adjust = NO;
		[mMovieView showController: showC adjustingSize: adjust];
		return errNone;		
	}
	if (strcmp(name, "copy")==0) {
		[mMovieView copy: NULL];
		return errNone;		
	}
	if (strcmp(name, "clear")==0) {
		[mMovieView clear: NULL];
		return errNone;		
	}
	if (strcmp(name, "cut")==0) {
		[mMovieView cut: NULL];
		return errNone;		
	}
	if (strcmp(name, "paste")==0) {
		[mMovieView paste: NULL];
		return errNone;		
	}					
	
	if (strcmp(name, "setCurrentTime")==0) {
		float time;
		err = slotFloatVal(slot, &time);
		if(err) return err;		
		SetMovieTimeValue(mMovie, (TimeValue) (time *  mTimeRecord.scale));
		return errNone;		
	}
		
	return SCView::setProperty(symbol, slot);
}

int SCMovieView::getProperty(PyrSymbol *symbol, PyrSlot *slot)
{
	char *name = symbol->name;
	//GetMovieDuration([[mMovieView movie] QTMovie]);
	if (strcmp(name, "getCurrentTime")==0) {
		float time;
		post("timescale: %d  \n",  mTimeRecord.scale);
		time = (float) ((float)GetMovieTime(mMovie, NULL) / mTimeRecord.scale);
		SetFloat(slot, time);
		return errNone;		
	}
	return SCView::getProperty(symbol, slot);
}

void SCMovieView::setVisibleFromParent()
{
	if(mVisible && mParent->isVisible()) {
		[mMovieView setHidden:NO];
	} else {
		[mMovieView setHidden:YES];
	}	
	[mMovieView setNeedsDisplay:YES];
	NSRect frame = [mMovieView frame];
	[mMovieView setFrame: NSInsetRect(frame,1,1)];
	[mMovieView setFrame: frame];
	mTop->resetFocus();
	refresh();
}

extern PyrSymbol *s_proto, *s_parent;
extern int ivxIdentDict_array, ivxIdentDict_size, ivxIdentDict_parent, ivxIdentDict_proto, ivxIdentDict_know;
int identDictPut(struct VMGlobals *g, PyrObject *dict, PyrSlot *key, PyrSlot *value);
extern PyrClass *class_identdict;

///////////
/*
SCQuartzComposerView by Scott Wilson
Copyright (c) 2007 Scott Wilson. All rights reserved.
Development funded in part by the Arts and Humanites Research Council http://www.ahrc.ac.uk/
*/

SCView* NewSCQuartzComposerView(SCContainerView *inParent, PyrObject* inObj, SCRect inBounds)
{
	return new SCQuartzComposerView(inParent, inObj, inBounds);
}

SCQuartzComposerView::SCQuartzComposerView(SCContainerView *inParent, PyrObject* inObj, SCRect inBounds)
: SCView(inParent, inObj, inBounds)
{
	NSRect matrect = SCtoNSRect(mBounds);
	mQCView = [[QCView alloc] initWithFrame:matrect];
	[mQCView setEventForwardingMask: NSAnyEventMask];
	NSView *view = mTop->GetNSView();	
	[view addSubview: mQCView];
	setVisibleFromParent();
}

SCQuartzComposerView::~SCQuartzComposerView()
{
	[mQCView removeFromSuperview];
	[mQCView release];
}


void SCQuartzComposerView::setBounds(SCRect screct)
{
	[[mQCView superview] setNeedsDisplayInRect:[mQCView frame]];
	mBounds = screct;
	if(mParent->relativeOrigin()){
		SCRect pbounds = mParent->getLayout().bounds; 	// relative origin fix
		mLayout.bounds.x = mBounds.x + pbounds.x;
		mLayout.bounds.y = mBounds.y + pbounds.y;
		mLayout.bounds.width = mBounds.width;
		mLayout.bounds.height = mBounds.height;	
	} else {
		mLayout.bounds = mBounds;
	}	
	[mQCView setFrame: SCtoNSRect(mLayout.bounds)];
	[mQCView setNeedsDisplay: YES];
	
}


int SCQuartzComposerView::setProperty(PyrSymbol *symbol, PyrSlot *slot)
{	
	char *name = symbol->name;
	
	if (strcmp(name, "visible")==0) {
		bool visible = IsTrue(slot);
//		if(visible  && mParent->isVisible()) 
//		{
//			[mQCView setHidden:NO];
//		}
//		else
//		{
//			[mQCView setHidden:YES];
//			mTop->resetFocus(); 
//		}
		mVisible = visible; 
		setVisibleFromParent();
		return errNone;
	}
	
	if (strcmp(name, "bounds")==0) {
		SCRect screct;
		int err = slotGetSCRect(slot, &screct);
		if (err) return err;
		mBounds = screct;
		setBounds(screct);
		return errNone;
	}
	
	if (strcmp(name, "loadCompositionFromFile")==0) {
		if(!isKindOfSlot(slot, class_string)) return errWrongType;
		PyrString* pstring = slot->uos;
		if(!pstring) return errNone;
		NSString *string = [[NSString alloc] initWithCString: pstring->s length: pstring->size];		
		BOOL success = [mQCView loadCompositionFromFile: string];
		if(!success) return errFailed;
		[string release];
		return errNone;
	}
	
	if (strcmp(name, "stop")==0) {
		[mQCView stopRendering];
		return errNone;
	}
	
	if (strcmp(name, "start")==0) {
		BOOL success = [mQCView startRendering];
		if(!success) return errFailed;
		return errNone;	
	}
	
	//// doesn't seem to work ; fix later
	//	if (strcmp(name, "erase")==0) {
	//		[mQCView erase];
	//		return errNone;	
	//	}
	//	
//	if (strcmp(name, "eraseColor")==0) {
//		SCColor rgb;
//		int err = slotColorVal(slot, &rgb);
//		if (err) return err;
//		NSColor *color = [NSColor colorWithCalibratedRed: rgb.red green: rgb.green blue: rgb.blue alpha: rgb.alpha];
//		//NSLog(@"color: %@", color);
//		//NSColor *color = [NSColor blueColor];
//		[mQCView setEraseColor: color];
//		[mQCView erase];
//		return errNone;	
//	}
	
	if (strcmp(name, "setMaxRenderingFrameRate")==0) {
		float rate;
		int err = slotFloatVal(slot, &rate);
		if (err) return err;
		[mQCView setMaxRenderingFrameRate: rate];
		return errNone;	
	}
	
	if (strcmp(name, "setInputValue")==0) {
		if(!isKindOfSlot(slot, class_array)) return errWrongType;
		PyrSlot *slots = slot->uo->slots;
		PyrSymbol *keysymbol;
		int err = slotSymbolVal(slots + 0, &keysymbol);
		if (err) return err;
		
		NSString *key = [[NSString alloc] initWithCString: keysymbol->name encoding: NSASCIIStringEncoding];
		if(![[mQCView inputKeys] containsObject: key]) {
			[key release];
			//post("There is no port with key \"%s\".\n\n", [key cString]); 
			return errFailed;
		}
		
		id nsObject = getNSObjectForSCObject(slots + 1, &err);
		if(!nsObject) {[key release]; return err;}
		BOOL success = [mQCView setValue: nsObject forInputKey: key];
		[key release];
		if(!success) return errFailed;
		return errNone;	
		
	}
	
	return SCView::setProperty(symbol, slot);
}

id SCQuartzComposerView::getNSObjectForSCObject(PyrSlot *scobject, int *returnErr) {

	int err;
	// find the value type and set appropriately
	if(((scobject->utag & 0xFFFFFFF0) != 0x7FF90000)) { // it's a float
		float val;
		err = slotFloatVal(scobject, &val);
		if (err) {returnErr = &err; return NULL;}
		NSNumber *returnObject = [NSNumber numberWithFloat: val];
		if(!returnObject) { err = errFailed; returnErr = &err; return NULL;}
		return returnObject;
	} else if((scobject->utag == tagInt)) { // it's an int
		int val;
		err = slotIntVal(scobject, &val);
		if (err) {returnErr = &err; return NULL;}
		NSNumber *returnObject = [NSNumber numberWithInt: val];
		if(!returnObject) { err = errFailed; returnErr = &err; return NULL;}
		return returnObject;	
	} else if((scobject->utag == tagTrue)) { // it's bool true
		NSNumber *returnObject = [NSNumber numberWithBool: YES];
		if(!returnObject) { err = errFailed; returnErr = &err; return NULL;}
		return returnObject;	
	} else if((scobject->utag == tagFalse)) { // it's bool false
		NSNumber *returnObject = [NSNumber numberWithBool: NO];
		if(!returnObject) { err = errFailed; returnErr = &err; return NULL;}
		return returnObject;
	} else if(isKindOfSlot(scobject, s_string->u.classobj)) { // it's a string
		PyrString *string = scobject->uos;
		if(string->size == 0) { err = errFailed; returnErr = &err; return NULL;}
		NSString *returnObject =  [NSString stringWithCString: string->s length: string->size];
		if(!returnObject) { err = errFailed; returnErr = &err; return NULL;}
		return returnObject;
	} else if(isKindOfSlot(scobject, s_color->u.classobj)) { // it's a color
		SCColor rgb;
		err = slotColorVal(scobject, &rgb);
		if (err) {returnErr = &err; return NULL;}
		NSColor *returnObject = [NSColor colorWithCalibratedRed: rgb.red green: rgb.green blue: rgb.blue alpha: rgb.alpha];
		if(!returnObject) { err = errFailed; returnErr = &err; return NULL;}
		return returnObject;
	} else if(isKindOfSlot(scobject, s_identitydictionary->u.classobj)) { // it's a structure (dict)
		PyrObject *array;
		array = (scobject)->uo->slots[ivxIdentDict_array].uo;
		if (!isKindOf((PyrObject*)array, class_array)) { err = errFailed; returnErr = &err; return NULL;}
		NSMutableDictionary *structure = [NSMutableDictionary dictionary];
		int len = array->size;
		
		for(int i=0; i<len; i=i+2){
			PyrSlot *element = array->slots+i;
			if(!IsNil(element)) {
				PyrSymbol *keysymbol;
				err = slotSymbolVal(element, &keysymbol);
				if (err) {returnErr = &err; return NULL;}
				NSString *key = [[NSString alloc] initWithCString: keysymbol->name encoding: NSASCIIStringEncoding];
				int innerErr;
				id innerSCObject = getNSObjectForSCObject(element + 1, &innerErr);
				if(!innerSCObject) { returnErr = &innerErr; return NULL;}
				[structure setObject: innerSCObject forKey: key];
			}
		}
		err = errNone;
		returnErr = &err;
		return structure;
	} else if(isKindOfSlot(scobject, class_array)) { // it's a structure (array)
		PyrSlot *array = scobject;
		int len = array->uo->size;
		NSMutableArray *structure = [NSMutableArray arrayWithCapacity: (unsigned)len];

		for(int i =0; i<len; i++){
			PyrSlot *element = array->uo->slots+i;
			int innerErr;
			id innerSCObject = getNSObjectForSCObject(element, &innerErr);
			if(!innerSCObject) { returnErr = &innerErr; return NULL;}
			[structure addObject: innerSCObject];
		}

		err = errNone;
		returnErr = &err;
		return structure;	
	} else if(isKindOfSlot(scobject, s_scimage->u.classobj)) { // it's an SCImage : )
		SCImage *scimage = (SCImage *)scobject->uo->slots[0].uptr;
		if(scimage) {
			if([scimage isAccelerated]) 
				return [scimage ciimage];
			else 
				return [scimage nsimage];
		}
		else {
			post("SCQuartzComposerView: invalid SCImage as input port !");
			err = errWrongType;
			returnErr = &err;
			return NULL;
		}
	} else {
		err = errWrongType; // it's something else...
		returnErr = &err;
		return NULL;
	}

}

int SCQuartzComposerView::getProperty(PyrSymbol *symbol, PyrSlot *slot)
{
	char *name = symbol->name;
	if (strcmp(name, "getOutputValue")==0) {
		PyrSymbol *keysymbol;
		int err = slotSymbolVal(slot, &keysymbol);
		if (err) return err;
		
		NSString *key = [[NSString alloc] initWithCString: keysymbol->name encoding: NSASCIIStringEncoding];
		if(![[mQCView outputKeys] containsObject: key]) {
			[key release];
			//post("There is no port with key \"%s\".\n\n", [key cString]); 
			return errFailed;
		}
		
		NSDictionary *outputAttributes = [[mQCView attributes] objectForKey: key];
		NSString *type = [outputAttributes objectForKey:QCPortAttributeTypeKey];
		
		id nsObject = [mQCView valueForOutputKey: key];
		[key release];
		err = getSCObjectForNSObject(slot, nsObject, type);
		if (err) return err;
		return errNone;
		
	} else if(strcmp(name, "getInputValue")==0) {
		PyrSymbol *keysymbol;
		int err = slotSymbolVal(slot, &keysymbol);
		if (err) return err;
		
		NSString *key = [[NSString alloc] initWithCString: keysymbol->name encoding: NSASCIIStringEncoding];
		if(![[mQCView inputKeys] containsObject: key]) {
			[key release];
			//post("There is no port with key \"%s\".\n\n", [key cString]); 
			return errFailed;
		}
		
		NSDictionary *inputAttributes = [[mQCView attributes] objectForKey: key];
		NSString *type = [inputAttributes objectForKey:QCPortAttributeTypeKey];
		
		id nsObject = [mQCView valueForInputKey: key];
		[key release];
		err = getSCObjectForNSObject(slot, nsObject, type);
		if (err) return err;
		return errNone;
		
	} else if(strcmp(name, "getInputKeys")==0) {
		NSArray* inputKeys = [mQCView inputKeys];
		int size = [inputKeys count];
		VMGlobals *g = gMainVMGlobals;
		PyrObject* array = newPyrArray(g->gc, size, 0, true);
		SetObject(slot, array);
		
		for (int i=0; i<size; ++i) {
			NSString *name = [inputKeys objectAtIndex: i];
			PyrString *string = newPyrString(g->gc, [name UTF8String], 0, true);
			SetObject(array->slots + array->size, string);
			array->size++;
			g->gc->GCWrite(array, string);
		}
		
		return errNone;
		
	} else if(strcmp(name, "getOutputKeys")==0) {
		NSArray* inputKeys = [mQCView outputKeys];
		int size = [inputKeys count];
		VMGlobals *g = gMainVMGlobals;
		PyrObject* array = newPyrArray(g->gc, size, 0, true);
		SetObject(slot, array);
		
		for (int i=0; i<size; ++i) {
			NSString *name = [inputKeys objectAtIndex: i];
			PyrString *string = newPyrString(g->gc, [name UTF8String], 0, true);
			SetObject(array->slots + array->size, string);
			array->size++;
			g->gc->GCWrite(array, string);
		}
		
		return errNone;
	}

	return SCView::getProperty(symbol, slot);
}

int SCQuartzComposerView::getSCObjectForNSObject(PyrSlot *slot, id nsObject, NSString *type) 
{
	if([type isEqualToString:QCPortTypeBoolean]) {
		SetBool(slot, [nsObject boolValue]);
		return errNone;
	} else if([type isEqualToString:QCPortTypeIndex]) {
		SetInt(slot, [nsObject intValue]);
		return errNone;
	} else if([type isEqualToString:QCPortTypeNumber]) {
		SetFloat(slot, [nsObject floatValue]);
		return errNone;
	} else if([type isEqualToString:QCPortTypeString]) {
		const char * cstr = [nsObject UTF8String];
		PyrString *string = newPyrString(NULL, cstr, 0, true);
		SetObject(slot, string);
		return errNone;
	} else if([type isEqualToString:QCPortTypeColor]) {
		
		VMGlobals *g = gMainVMGlobals;
		PyrObject* colorObj = instantiateObject(g->gc, s_color->u.classobj, 0, false, true);
		SCColor rgb = SCMakeColor([nsObject redComponent], [nsObject greenComponent], [nsObject blueComponent], [nsObject alphaComponent]);
		SetObject(slot, colorObj);
		int err = setSlotColor(slot, &rgb);
		if (err) { return err;}
		return errNone;
	} else if([type isEqualToString:QCPortTypeStructure]) {
		//NSLog(@"QCPortTypeStructure");
		//NSLog(@"class: %@", [nsObject class]);
		
		// for the moment QC seems to deal with all internal structures as NSCFDictionary
		// but check here to be safe
		if([nsObject isKindOfClass: [NSDictionary class]]){
			//NSLog(@"it's a dict");
			PyrObject *dict, *array;
			VMGlobals *g = gMainVMGlobals;
			
			dict = instantiateObject(g->gc, class_identdict, 5, true, false);
			array = newPyrArray(g->gc, 4, 0, false);
			array->size = 4;
			nilSlots(array->slots, array->size);
			SetObject(dict->slots + ivxIdentDict_array, array);
			g->gc->GCWrite(dict, array);
			SetObject(slot, dict);
			
			NSEnumerator *enumerator = [nsObject keyEnumerator];
			id key;
			
			while ((key = [enumerator nextObject])) {
				//NSLog(@"key class: %@", [key class]);
				id innerNSObject = [nsObject objectForKey: key];
				//NSLog(@"innerNSObject: %@", innerNSObject);
				PyrSlot innerSlot;
				NSString *innerType;
				
				if([innerNSObject isKindOfClass: [NSNumber class]]){
					//NSLog(@"objCType: %s", [innerNSObject objCType]);
					if(!strcmp([innerNSObject objCType], @encode(BOOL))) {
						//NSLog(@"Number");
						innerType = QCPortTypeBoolean;
					} else if(!strcmp([innerNSObject objCType], @encode(int))) {
						innerType = QCPortTypeIndex;
					} else innerType = QCPortTypeNumber;
				} else if([innerNSObject isKindOfClass: [NSColor class]]){
					//NSLog(@"Color");
					innerType = QCPortTypeColor;
				} else if([innerNSObject isKindOfClass: [NSString class]]){
					//NSLog(@"String");
					innerType = QCPortTypeString;
				} else if([innerNSObject isKindOfClass: [NSArray class]] || [innerNSObject isKindOfClass: [NSDictionary class]]){
					//NSLog(@"Structure");
					innerType = QCPortTypeStructure;
				} else return errWrongType; // it's something else
				
				//NSLog(@"innerObject Class: %@", [innerNSObject class]);
				int err = getSCObjectForNSObject(&innerSlot, innerNSObject, innerType);
				if(err) return err;
				
				PyrSlot outKey;
				SetSymbol(&outKey, getsym([key cString]));
				err = identDictPut(g, dict, &outKey, &innerSlot);
				if(err) return err;
			}
			

			return errNone;
		}

	}
	else if([type isEqualToString:QCPortTypeImage]) { // SCImage
		NSImage *nsimage = (NSImage*)nsObject;
		if(!nsimage) 
			post("SCQuartzComposerView: bad return value as QCPortTypeImage");
		
		SCImage *scimage = [[SCImage alloc]initWithNSImage:nsimage];
		if(scimage) {
			VMGlobals *g		= gMainVMGlobals;
			PyrObject *object	= newPyrSCImage(g); // should be garbage collected
			if(object) {
				PyrSlot		*slots	= object->slots;
				SetObject(slot, object);
				SetPtr(slots + 0, scimage);
				SetFloat(slots + 1, (float)[scimage width]);
				SetFloat(slots + 2, (float)[scimage height]);
				return errNone;
			}
		}
		else {
			post("SCQuartzComposerView: failed NSImage to SCImage conversion !");
		}
	}
	return errWrongType; // it's something else	

		
}

void SCQuartzComposerView::setVisibleFromParent()
{
	if(mVisible && mParent->isVisible()) {
		[mQCView setHidden:NO];
		return;
	} else {
		[mQCView setHidden:YES];
	}	
	mTop->resetFocus();
}
